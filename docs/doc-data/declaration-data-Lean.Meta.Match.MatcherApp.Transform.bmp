{"name":"Lean.Meta.Match.MatcherApp.Transform","instances":[],"imports":["Lean.Meta.Match","Lean.Meta.InferType","Lean.Meta.Check","Lean.Meta.Tactic.Split"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L369-L439","name":"Lean.Meta.MatcherApp.inferMatchType","line":369,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.inferMatchType","doc":"Given a `MatcherApp`, replaces the motive with one that is inferred from the actual types of the\nalternatives.\n\nFor example, given\n```\n(match (motive := Nat → Unit → ?) n with\n 0 => 1\n _ => true) ()\n```\n(for any `?`; the motive’s result type be ignored) will give this type\n```\n(match n with\n | 0 => Nat\n | _ => Bool)\n```\n\nThe given `MatcherApp` must not use a splitter in `matcherName`.\nThe resulting expression *will* use the splitter corresponding to `matcherName` (this is necessary\nfor the construction).\n\nInternally, this needs to reduce the matcher in a given branch; this is done using\n`Split.simpMatchTarget`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.inferMatchType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">inferMatchType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L197-L365","name":"Lean.Meta.MatcherApp.transform","line":197,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.transform","doc":"Performs a possibly type-changing transformation to a `MatcherApp`.\n\n* `onParams` is run on each parameter and discriminant\n* `onMotive` runs on the body of the motive, and is passed the motive parameters\n  (one for each `MatcherApp.discrs`)\n* `onAlt` runs on each alternative, and is passed the expected type of the alternative,\n   as inferred from the motive\n* `onRemaining` runs on the remaining arguments (and may change their number)\n\nIf `useSplitter` is true, the matcher is replaced with the splitter.\nNB: Not all operations on `MatcherApp` can handle one `matcherName` is a splitter.\n\nIf `addEqualities` is true, then equalities connecting the discriminant to the parameters of the\nalternative (like in `match h : x with …`) are be added, if not already there.\n\nThis function works even if the type of alternatives do *not* fit the inferred type. This\nallows you to post-process the `MatcherApp` with `MatcherApp.inferMatchType`, which will\ninfer a type, given all the alternatives.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.transform\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">transform</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">MonadError</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.MonadEnv\">MonadEnv</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Log.html#Lean.MonadLog\">MonadLog</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Message.html#Lean.AddMessageContext\">AddMessageContext</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.MonadOptions\">MonadOptions</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">useSplitter </span><span class=\"fn\">addEqualities</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">onParams</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">onMotive</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>) (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">e</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">onAlt</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">e</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">onRemaining</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L175-L182","name":"Lean.Meta.MatcherApp.withUserNames","line":175,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.withUserNames","doc":"Sets the user name of the FVars in the local context according to the given array of names.\n\nIf they differ in size the shorter size wins.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.withUserNames\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">withUserNames</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L161-L167","name":"Lean.Meta.MatcherApp.refineThrough?","line":161,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough?","doc":"A non-failing version of `MatcherApp.refineThrough` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">refineThrough?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L107-L159","name":"Lean.Meta.MatcherApp.refineThrough","line":107,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough","doc":"Given\n- matcherApp `match_i As (fun xs => motive[xs]) discrs (fun ys_1 => (alt_1 : motive (C_1[ys_1])) ... (fun ys_n => (alt_n : motive (C_n[ys_n]) remaining`, and\n- a expression `B[discrs]` (which may not be a type, e.g. `n : Nat`),\nreturns the expressions `fun ys_1 ... ys_i => B[C_1[ys_1]] ... B[C_n[ys_n]]`,\n\nThis method assumes\n- the `matcherApp.motive` is a lambda abstraction where `xs.size == discrs.size`\n- each alternative is a lambda abstraction where `ys_i.size == matcherApp.altNumParams[i]`\n\nThis is similar to `MatcherApp.addArg` when you only have an expression to\nrefined, and not a type with a value.\n\nThis is used in `Lean.Elab.PreDefinition.WF.GuessFix` when constructing the context of recursive\ncalls to refine the functions' parameter, which may mention `major`.\nSee there for how to use this function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">refineThrough</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L99-L104","name":"Lean.Meta.MatcherApp.addArg?","line":99,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?","doc":"Similar to `MatcherApp.addArg`, but returns `none` on failure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">addArg?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Match/MatcherApp/Transform.lean#L40-L97","name":"Lean.Meta.MatcherApp.addArg","line":40,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg","doc":"Given\n- matcherApp `match_i As (fun xs => motive[xs]) discrs (fun ys_1 => (alt_1 : motive (C_1[ys_1])) ... (fun ys_n => (alt_n : motive (C_n[ys_n]) remaining`, and\n- expression `e : B[discrs]`,\nConstruct the term\n`match_i As (fun xs => B[xs] -> motive[xs]) discrs (fun ys_1 (y : B[C_1[ys_1]]) => alt_1) ... (fun ys_n (y : B[C_n[ys_n]]) => alt_n) e remaining`.\n\nWe only abstract discriminants that are fvars.  We used to use `kabstract` to abstract all\ndiscriminants from `B[discrs]`, but that changes the type of the arg in ways that make it no\nlonger compatible with the original recursive function (issue #7322).\n\nIf this is still not great, then we could try to use `kabstract`, but only on the last parameter\nof the `arg` (the termination proof obligation).\n\nThis method assumes\n- the `matcherApp.motive` is a lambda abstraction where `xs.size == discrs.size`\n- each alternative is a lambda abstraction where `ys_i.size == matcherApp.altNumParams[i]`\n\nThis is used in `Lean.Elab.PreDefinition.WF.Fix` when replacing recursive calls with calls to\nthe argument provided by `fix` to refine type of the local variable used for recursive calls,\nwhich may mention `major`. See there for how to use this function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">addArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcherApp</span> : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">MatcherApp</a></span></div></div>"}]}