{"name":"Lean.Meta.Tactic.Grind.MatchCond","instances":[],"imports":["Init.Grind","Init.Simproc","Lean.Meta.Tactic.Contradiction","Lean.Meta.Tactic.Grind.ProveEq","Lean.Meta.Tactic.Grind.PropagatorAttr"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L419-L423","name":"Lean.Meta.Grind.propagateMatchCondDown","line":419,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondDown","doc":"Propagates `MatchCond` downwards "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondDown\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">propagateMatchCondDown</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator\">Propagator</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L406-L417","name":"Lean.Meta.Grind.propagateMatchCondUp","line":406,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondUp","doc":"Propagates `MatchCond` upwards "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondUp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">propagateMatchCondUp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator\">Propagator</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L384-L404","name":"Lean.Meta.Grind.tryToProveFalse.go","line":384,"kind":"opaque","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse.go","doc":"Returns a term that is equal to `e`, but containing constructor applications\nand literal values. `e` is the left-hand side of the equations in a `match`-expression\ncondition.\nRemark: we could use the right-hand side to interrupt the recursion. For example,\nsuppose the equation is `x = ?head :: ?tail`. We only need to show that `x` is equal to\nsome term of the form `a :: as` to satisfy it. This function may return `a₁ :: b :: bs`,\nwhich still allows us to satisfy the equation, but may have a bigger proof (e.g.,\na proof that `as` is equal to `b::bs`)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">tryToProveFalse</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L317-L404","name":"Lean.Meta.Grind.tryToProveFalse","line":317,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse","doc":"Given a `match`-expression condition `e` that is known to be equal to `True`,\ntry to close the goal by proving `False`. We use the following to example to illustrate\nthe purpose of this function.\n```\ndef f : List Nat → List Nat → Nat\n  | _, 1 :: _ :: _ => 1\n  | _, _ :: _ => 2\n  | _, _  => 0\n\nexample : z = a :: as → y = z → f x y > 0 := by\n  grind [f.eq_def]\n```\nAfter `grind` unfolds `f`, it case splits on the `match`-expression producing\nthree subgoals. The first two are easily closed by it. In the third one,\nwe have the following two `match`-expression conditions stating that we\nare **not** in the first and second cases.\n```\nLean.Grind.MatchCond (∀ (head : Nat) (tail : List Nat), x✝² = 1 :: head :: tail → False)\nLean.Grind.MatchCond (∀ (head : Nat) (tail : List Nat), x✝² = head :: tail → False)\n```\nMoreover, we have the following equivalence class.\n```\n{z, y, x✝², a :: as}\n```\nThus, we can close the goal by using the second `match`-expression condition,\nwe just have to instantiate `head` and `tail` with `a` and `as` respectively,\nand use the fact that `x✝²` is equal to `a :: as`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">tryToProveFalse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L183-L191","name":"Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go.replaceLhss","line":183,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go.replaceLhss","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go.replaceLhss\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">collectMatchCondLhssAndAbstract</span>.<span class=\"name\">go</span>.<span class=\"name\">replaceLhss</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L172-L195","name":"Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go","line":172,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">collectMatchCondLhssAndAbstract</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhssαs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tysxs </span><span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L121-L196","name":"Lean.Meta.Grind.collectMatchCondLhssAndAbstract","line":121,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract","doc":"Given `e` a `match`-expression condition, returns the left-hand side\nof the ground equations, **and** function application that abstracts the left-hand sides.\nAs an example, assume we have a `match`-expression condition `C₁` of the form\n```\nGrind.MatchCond (∀ y₁ y₂ y₃, t = .mk₁ y₁ → s = .mk₂ y₂ y₃ → False)\n```\nthen the result returned by this function is\n```\n(#[t, s], (fun x₁ x₂ => (∀ y₁ y₂ y₃, x₁ = .mk₁ y₁ → x₂ = .mk₂ y₂ y₃ → False)) t s)\n```\nNote that the returned expression is definitionally equal to `C₁`.\nWe use this expression to detect whether two different `match`-expression conditions are\ncongruent.\nFor example, suppose we also have the `match`-expression `C₂` of the form\n```\nGrind.MatchCond (∀ y₁ y₂ y₃, a = .mk₁ y₁ → b = .mk₂ y₂ y₃ → False)\n```\nThis function would return\n```\n(#[a, b], (fun x₁ x₂ => (∀ y₁ y₂ y₃, x₁ = .mk₁ y₁ → x₂ = .mk₂ y₂ y₃ → False)) a b)\n```\nNote that the lambda abstraction is identical to the first one. Let's call it `l`.\nThus, we can write the two pairs above as\n- `(#[t, s], l t s)`\n- `(#[a, b], l a b)`\nMoreover, `C₁` is definitionally equal to `l t s`, and `C₂` is definitionally equal to `l a b`.\nThen, if `grind` infers that `t = a` and `s = b`, it will detect that `l t s` and `l a b` are\nequal by congruence, and consequently `C₁` is equal to `C₂`.\n\nGruesome details for heterogenenous equalities.\n\nWhen pattern matching on indexing families, the generated conditions often use heterogenenous equalities. Here is an example:\n```\n(∀ (x : Vec α 0), n = 0 → HEq as Vec.nil → HEq bs x → False)\n```\nIn this case, it is not sufficient to abstract the left-hand side. We also have\nto abstract its type. The following is produced in this case.\n```\n(#[n, Vec α n, as, Vec α n, bs],\n (fun (x_0 : Nat) (ty_1 : Type u_1) (x_1 : ty_1) (ty_2 : Type u_1) (x_2 : ty_2) =>\n    ∀ (x : Vec α 0), x_0 = 0 → HEq x_1 Vec.nil → HEq x_2 x → False)\n n (Vec α n) as (Vec α n) bs)\n```\nThe example makes it clear why this is needed, `as` and `bs` depend on `n`.\nNote that we can abstract the type without introducing typer errors because\nheterogenenous equality is used for `as` and `bs`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">collectMatchCondLhssAndAbstract</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchCond</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>"}]}