{"name":"Init.Guard","instances":[],"imports":["Init.Tactics","Init.Conv","Init.NotationExtra"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L112-L127","name":"Lean.Parser.Command.guardCmd","line":112,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Command.guardCmd","doc":"Command to check that an expression evaluates to `true`.\n\n`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that\nthe result is `true`. The term is elaborated *without* variables declared using `variable`, since\nthese cannot be evaluated.\n\nSince this makes use of coercions, so long as a proposition `p` is decidable, one can write\n`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable\nequality one can write `#guard a = b`. Note that this is not exactly the same as checking\nif `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do\nthe evaluation.\n\nNote: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the\nexpression equals `true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Command.guardCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">guardCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L102-L110","name":"Lean.Parser.Command.guardExprCmd","line":102,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Command.guardExprCmd","doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Command.guardExprCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">guardExprCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L95-L96","name":"Lean.Parser.Tactic.guardHypConv","line":95,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardHypConv","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardHypConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardHypConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L79-L94","name":"Lean.Parser.Tactic.guardHyp","line":79,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardHyp","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardHyp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L76-L77","name":"Lean.Parser.Tactic.guardTargetConv","line":76,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardTargetConv","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardTargetConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardTargetConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L65-L75","name":"Lean.Parser.Tactic.guardTarget","line":65,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardTarget","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardTarget\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L62-L63","name":"Lean.Parser.Tactic.guardExprConv","line":62,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardExprConv","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardExprConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardExprConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L50-L61","name":"Lean.Parser.Tactic.guardExpr","line":50,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardExpr","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L45-L46","name":"Lean.Parser.equal","line":45,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.equal","doc":"The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L43-L44","name":"Lean.Parser.equalA","line":43,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.equalA","doc":"Alpha-eq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L41-L42","name":"Lean.Parser.equalS","line":41,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.equalS","doc":"Syntactic matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L39-L40","name":"Lean.Parser.equalD","line":39,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.equalD","doc":"Default-reducibility defeq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L37-L38","name":"Lean.Parser.equalR","line":37,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.equalR","doc":"Reducible defeq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L34-L35","name":"Lean.Parser.colonEq","line":34,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonEq","doc":"The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L32-L33","name":"Lean.Parser.colonEqA","line":32,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonEqA","doc":"Alpha-eq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L30-L31","name":"Lean.Parser.colonEqS","line":30,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonEqS","doc":"Syntactic matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L28-L29","name":"Lean.Parser.colonEqD","line":28,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonEqD","doc":"Default-reducibility defeq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L26-L27","name":"Lean.Parser.colonEqR","line":26,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonEqR","doc":"Reducible defeq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L23-L24","name":"Lean.Parser.colon","line":23,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colon","doc":"The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colon</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L21-L22","name":"Lean.Parser.colonA","line":21,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonA","doc":"Alpha-eq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L19-L20","name":"Lean.Parser.colonS","line":19,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonS","doc":"Syntactic matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L17-L18","name":"Lean.Parser.colonD","line":17,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonD","doc":"Default-reducibility defeq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Guard.lean#L15-L16","name":"Lean.Parser.colonR","line":15,"kind":"def","docLink":"./Init/Guard.html#Lean.Parser.colonR","doc":"Reducible defeq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"}]}