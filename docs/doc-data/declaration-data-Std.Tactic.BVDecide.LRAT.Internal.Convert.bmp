{"name":"Std.Tactic.BVDecide.LRAT.Internal.Convert","instances":[],"imports":["Std.Sat.CNF.RelabelFin","Std.Tactic.BVDecide.LRAT.Internal.Formula"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L116-L140","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","line":116,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_convertLRAT_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>))</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L106-L114","name":"Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","line":106,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">unsat_of_cons_none_unsat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clauses</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">DefaultFormula.ofArray</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option.none\">none</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">clauses</span>).<a href=\"./Init/Prelude.html#List.toArray\">toArray</a></span>)</span></span> →\n  <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">DefaultFormula.ofArray</a> <span class=\"fn\"><span class=\"fn\">clauses</span>.<a href=\"./Init/Prelude.html#List.toArray\">toArray</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L101-L104","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","line":101,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRatAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Lemmas.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ReadyForRatAdd\">ReadyForRatAdd</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L96-L99","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","line":96,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRupAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Lemmas.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ReadyForRupAdd\">ReadyForRupAdd</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L82-L94","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","line":82,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","doc":"Convert a `CNF Nat` with a certain maximum variable number into the `DefaultFormula`\nformat for usage with `bv_decide`'s `LRAT.Internal`.\n\nNotably this:\n1. Increments all variables as DIMACS variables start at 1 instead of 0\n2. Adds a leading `none` clause. This clause *must* be persistent as the LRAT checker wants to have\n  the DIMACS file line by line and the DIMACS file begins with the `p cnf x y` meta instruction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula\">DefaultFormula</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L68-L80","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","line":68,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT_sat_of_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">lratClause</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">assign</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\">convertLRAT'</a> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause.eval\">Sat.CNF.Clause.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> → <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Entails.eval\">Entails.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">lratClause</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L58-L66","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","line":58,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">mem_lrat_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Sat.Literal</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">lratClause</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">clause</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray\">DefaultClause.ofArray</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List.toArray\">List.toArray</a> <span class=\"fn\">clause</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\">lratClause</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.clause\">clause</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L46-L56","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","line":46,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","doc":"Turn a `CNF PosFin` into the representation used by the LRAT checker.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clauses</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L40-L44","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","line":40,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","doc":"Turn a `CNF.Clause PosFin` into the representation used by the LRAT checker.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L28-L38","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","line":28,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_lift_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\">lift</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span> → <span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L19-L26","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","line":19,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","doc":"Turn a `CNF Nat`, that might contain `0` as a variable, to a `CNF PosFin`.\nThis representation is guaranteed to not have `0` and is limited to an upper bound of\nvariable indices.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">lift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>))</span></span></div></div>"}]}