{"name":"Lean.Meta.Tactic.FunInd","instances":[],"imports":["Lean.Meta.Basic","Lean.Meta.Match.MatcherApp.Transform","Lean.Meta.Check","Lean.Meta.Tactic.Subst","Lean.Meta.Injective","Lean.Meta.ArgsPacker","Lean.Meta.PProdN","Lean.Elab.PreDefinition.WF.Eqns","Lean.Elab.PreDefinition.Structural.Eqns","Lean.Elab.PreDefinition.Structural.IndGroupInfo","Lean.Elab.PreDefinition.Structural.FindRecArg","Lean.Elab.Command","Lean.Meta.Tactic.ElimInfo","Lean.Meta.Tactic.FunIndInfo"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1478-L1489","name":"Lean.Tactic.FunInd.isFunCasesName","line":1478,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunCasesName","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunCasesName\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">isFunCasesName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1457-L1475","name":"Lean.Tactic.FunInd.isFunInductName","line":1457,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">isFunInductName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1433-L1455","name":"Lean.Tactic.FunInd.deriveInduction","line":1433,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction","doc":"Given a recursively defined function `foo`, derives `foo.induct`. See the module doc for details.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1360-L1431","name":"Lean.Tactic.FunInd.deriveCases","line":1360,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveCases","doc":"For non-recursive (and recursive functions) functions we derive a “functional case splitting theorem”. This is very similar\nthan the functional induction theorem. It splits the goal, but does not give you inductive hyptheses.\n\nFor these, it is not really clear which parameters should be “targets” of the motive, as there is\nno “fixed prefix” to guide this decision. All? None? Some?\n\nWe tried none, but that did not work well. Right now it's all parameters, and it seems to work well.\nIn the future, we might post-process the theorem (or run the code below iteratively) and remove\ntargets that are unchanged in each case, so simplify applying the lemma when these “fixed” parameters\nare not variables, to avoid having to generalize them.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1133-L1357","name":"Lean.Tactic.FunInd.deriveInductionStructural.doRealize","line":1133,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural.doRealize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural.doRealize\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveInductionStructural</span>.<span class=\"name\">doRealize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParamPerms</span> : <a href=\"./Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms\">Elab.FixedParamPerms</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inductName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1120-L1357","name":"Lean.Tactic.FunInd.deriveInductionStructural","line":1120,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural","doc":"Given a recursive definition `foo` defined via structural recursion, derive `foo.mutual_induct`,\nif needed, and `foo.induct` for all functions in the group.\nSee module doc for details.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveInductionStructural</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParamPerms</span> : <a href=\"./Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms\">Elab.FixedParamPerms</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1113-L1118","name":"Lean.Tactic.FunInd.withLetDecls.go","line":1113,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">withLetDecls</span>.<span class=\"name\">go</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts </span><span class=\"fn\">es</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acc</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1109-L1118","name":"Lean.Tactic.FunInd.withLetDecls","line":1109,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">withLetDecls</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts </span><span class=\"fn\">es</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1067-L1107","name":"Lean.Tactic.FunInd.unpackMutualInduction.doRealize","line":1067,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction.doRealize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction.doRealize\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">unpackMutualInduction</span>.<span class=\"name\">doRealize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqnInfo</span> : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inductName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1055-L1107","name":"Lean.Tactic.FunInd.unpackMutualInduction","line":1055,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction","doc":"Retrieves `foo._unary.induct`, where the motive is a `PSigma`/`PSum` type, and\nunpacks it into a n-ary and (possibly) joint induction principle.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">unpackMutualInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqnInfo</span> : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L997-L1053","name":"Lean.Tactic.FunInd.cleanPackedArgs","line":997,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs","doc":"In the type of `value`, reduces\n* Beta-redexes\n* `PSigma.casesOn (PSigma.mk a b) (fun x y => k x y)  -->  k a b`\n* `PSum.casesOn (PSum.inl x) k₁ k₂                    -->  k₁ x`\n* `foo._unary (PSum.inl (PSigma.mk a b))              -->  foo a b`\nand then wraps `value` in an appropriate type hint.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanPackedArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqnInfo</span> : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">value</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L973-L995","name":"Lean.Tactic.FunInd.setNaryFunIndInfo","line":973,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.setNaryFunIndInfo","doc":"For a (non-mutual!) definition of `name`, uses the `FunIndInfo` associated with the `unaryInduct` and\nderives the one for the n-ary function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.setNaryFunIndInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">setNaryFunIndInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParamPerms</span> : <a href=\"./Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms\">Elab.FixedParamPerms</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name </span><span class=\"fn\">unaryInduct</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L953-L971","name":"Lean.Tactic.FunInd.projectMutualInduct","line":953,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.projectMutualInduct","doc":"Given a realizer for `foo.mutual_induct`, defines `foo.induct`, `bar.induct` etc.\nUsed for well-founded and structural recursion.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.projectMutualInduct\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">projectMutualInduct</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutualInduct</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">finalizeFirstInd</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L852-L951","name":"Lean.Tactic.FunInd.deriveUnaryInduction.doRealize","line":852,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction.doRealize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction.doRealize\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveUnaryInduction</span>.<span class=\"name\">doRealize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name </span><span class=\"fn\">inductName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L844-L951","name":"Lean.Tactic.FunInd.deriveUnaryInduction","line":844,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction","doc":"Given a unary definition `foo` defined via `WellFounded.fixF`, derive a suitable induction principle\n`foo.induct` for it. See module doc for details.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveUnaryInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfolding</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L809-L842","name":"Lean.Tactic.FunInd.abstractIndependentMVars","line":809,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars","doc":"Given an expression `e` with metavariables `mvars`\n* performs more cleanup:\n  * removes unused let-expressions after index `index`\n  * tries to substitute variables after index `index`\n* lifts them to the current context by reverting all local declarations after index `index`\n* introducing a local variable for each of the meta variable\n* assigning that local variable to the mvar\n* and finally lambda-abstracting over these new local variables.\n\nThis operation only works if the metavariables are independent from each other.\n\nThe resulting meta variable assignment is no longer valid (mentions out-of-scope\nvariables), so after this operations, terms that still mention these meta variables must not\nbe used anymore.\n\nWe are not using `mkLambdaFVars` on mvars directly, nor `abstractMVars`, as these at the moment\ndo not handle delayed assignments correctly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">abstractIndependentMVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">index</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L669-L807","name":"Lean.Tactic.FunInd.buildInductionBody","line":669,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody","doc":"Builds an expression of type `goal` by replicating the expression `e` into its tail-call-positions,\nwhere it calls `buildInductionCase`. Collects the cases of the final induction hypothesis\nas `MVars` as it goes.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">buildInductionBody</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toErase </span><span class=\"fn\">toClear</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oldIH </span><span class=\"fn\">newIH</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isRecCall</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L653-L667","name":"Lean.Tactic.FunInd.rwMatcher","line":653,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwMatcher","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwMatcher\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">rwMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L641-L651","name":"Lean.Tactic.FunInd.rwFun","line":641,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">rwFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L635-L639","name":"Lean.Tactic.FunInd.rwHaveWith","line":635,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwHaveWith","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwHaveWith\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">rwHaveWith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L629-L633","name":"Lean.Tactic.FunInd.rwLetWith","line":629,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwLetWith","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwLetWith\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">rwLetWith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L596-L627","name":"Lean.Tactic.FunInd.rwIfWith","line":596,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwIfWith","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwIfWith\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">rwIfWith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hc </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L581-L594","name":"Lean.Tactic.FunInd.inProdLambdaLastArg","line":581,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inProdLambdaLastArg","doc":"Use to write inside the packed motives used for mutual structural recursion.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inProdLambdaLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">inProdLambdaLastArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rw</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L573-L579","name":"Lean.Tactic.FunInd.withRewrittenMotiveArg","line":573,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotiveArg","doc":"If `goal` is of the form `motive a b e`, applies `rw` to `e`, passes the simplified\n`goal'` to `k` (which should return an expression of type `goal'`), and rewrites that term\naccordingly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotiveArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">withRewrittenMotiveArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rw</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L565-L571","name":"Lean.Tactic.FunInd.inLastArg","line":565,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">inLastArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rw</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L556-L563","name":"Lean.Tactic.FunInd.withRewrittenMotive","line":556,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive","doc":"Applies `rw` to `goal`, passes the rewritten `goal'` to `k` (which should return an expression of\ntype `goal'`), and wraps that using the proof from `rw`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">withRewrittenMotive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rw</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L549-L554","name":"Lean.Tactic.FunInd.maskArray","line":549,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray","doc":"`maskArray mask xs` keeps those `x` where the corresponding entry in `mask` is `true` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">maskArray</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mask</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L521-L547","name":"Lean.Tactic.FunInd.mkLambdaFVarsMasked","line":521,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked","doc":"Like `mkLambdaFVars (usedOnly := true)`, but\n\n * silently skips expression in `xs` that are not `.isFVar`\n * returns a mask (same size as `xs`) indicating which variables have been abstracted\n   (`true` means was abstracted).\n\nThe result `r` can be applied with `r.beta (maskArray mask args)`.\n\nWe use this when generating the functional induction principle to refine the goal through a `match`,\nhere `xs` are the discriminants of the `match`.\nWe do not expect non-trivial discriminants to appear in the goal (and if they do, the user will\nget a helpful equality into the context).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">mkLambdaFVarsMasked</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L503-L519","name":"Lean.Tactic.FunInd.buildInductionCase","line":503,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase","doc":"Base case of `buildInductionBody`: Construct a case for the final induction hypthesis.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">buildInductionCase</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oldIH </span><span class=\"fn\">newIH</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isRecCall</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toErase </span><span class=\"fn\">toClear</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L499-L500","name":"Lean.Tactic.FunInd.M2.branch","line":499,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.branch","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.branch\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M2</span>.<span class=\"name\">branch</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L496-L497","name":"Lean.Tactic.FunInd.M2.run","line":496,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.run","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.run\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M2</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\">M2</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L491-L494","name":"Lean.Tactic.FunInd.M2","line":491,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2","doc":"Second helper monad collecting the cases as mvars\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M2</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L476-L488","name":"Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?","line":476,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanupAfter</span>.<span class=\"name\">cleanupAfter?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">index</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">firstPass</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L467-L474","name":"Lean.Tactic.FunInd.cleanupAfter.allHeqToEq","line":467,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.allHeqToEq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.allHeqToEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanupAfter</span>.<span class=\"name\">allHeqToEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">index</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L461-L465","name":"Lean.Tactic.FunInd.cleanupAfter.go","line":461,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanupAfter</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">index</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">firstPass</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L445-L488","name":"Lean.Tactic.FunInd.cleanupAfter","line":445,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter","doc":"Goal cleanup:\nSubstitutes equations (with `substVar`) to remove superfluous variables, and clears unused\nlet bindings.\n\nSubstitutes from the outside in so that the inner-bound variable name wins, but does a first pass\nlooking only at variables with names with macro scope, so that preferably they disappear.\n\nCareful to only touch the context after the motives (given by the index) as the motive could depend\non anything before, and `substVar` would happily drop equations about these fixed parameters.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanupAfter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">index</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L439-L443","name":"Lean.Tactic.FunInd.assertIHs","line":439,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">assertIHs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vals</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarid</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L429-L437","name":"Lean.Tactic.FunInd.deduplicateIHs","line":429,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deduplicateIHs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vals</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L262-L423","name":"Lean.Tactic.FunInd.foldAndCollect","line":262,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect","doc":"The `foldAndCollect` function performs two operations together:\n\n * it fold recursive calls: applications (and projectsions) of `oldIH` in `e` correspond to\n   recursive calls, so this function rewrites that back to recursive calls\n * it collects induction hypotheses: after replacing `oldIH` with `newIH`, applications thereof\n   are valuable as induction hypotheses for the cases.\n\nFor well-founded recursion (unary, non-mutual by construction) the terms are rather simple: they\nare `oldIH arg proof`, and can be rewritten to `f arg` resp. `newIH arg proof`. But for\nstructural recursion this can be a more complicted mix of function applications (due to reflexive\ndata types or extra function arguments) and `PProd` projections (due to the below construction and\nmutual function packing), and the main function argument isn't even present.\n\nTo avoid having to think about this, we apply a nice trick:\n\nWe compositionally replace `oldIH` with `newIH`. This likely changes the result type, so when\nre-assembling we have to be supple (mainly around `PProd.fst`/`PProd.snd`). As we re-assemble\nthe term we check if it has type `motive xs..`. If it has, then know we have just found and\nrewritten a recursive call, and this type nicely provides us the arguments `xs`. So at this point\nwe store the rewritten expression as a new induction hypothesis (using `M.tell`) and rewrite to\n`f xs..`, which now again has the same type as the original term, and the further re-assembly should\nwork. Half this logic is in the `isRecCall` parameter.\n\nIf this process fails we’ll get weird type errors (caught later on). We'll see if we need to\nimprove the errors, for example by passing down a flag whether we expect the same type (and no\noccurrences of `newIH`), or whether we are in “supple mode”, and catch it earlier if the rewriting\nfails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">foldAndCollect</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oldIH </span><span class=\"fn\">newIH</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isRecCall</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L257-L258","name":"Lean.Tactic.FunInd.M.branch","line":257,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.branch","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.branch\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">branch</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L255-L255","name":"Lean.Tactic.FunInd.M.ask","line":255,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.ask","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.ask\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">ask</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L252-L253","name":"Lean.Tactic.FunInd.M.localMapM","line":252,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localMapM","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localMapM\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">localMapM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L247-L250","name":"Lean.Tactic.FunInd.M.localM","line":247,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localM","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localM\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">localM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L245-L245","name":"Lean.Tactic.FunInd.M.tell","line":245,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.tell","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.tell\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">tell</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L243-L243","name":"Lean.Tactic.FunInd.M.exec","line":243,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.exec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.exec\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">exec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L242-L242","name":"Lean.Tactic.FunInd.M.eval","line":242,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.eval\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L241-L241","name":"Lean.Tactic.FunInd.M.run","line":241,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L228-L235","name":"Lean.Tactic.FunInd.M","line":228,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M","doc":"A monad to help collecting inductive hypothesis.\n\nIn `foldAndCollect` it's a writer monad (with variants of the `local` combinator),\nand in `buildInductionBody` it is more of a reader monad, with inductive hypotheses\nbeing passed down (hence the `ask` and `branch` combinator).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L212-L216","name":"Lean.Tactic.FunInd.lambdaTelescope1","line":212,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.lambdaTelescope1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.lambdaTelescope1\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">lambdaTelescope1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">MonadError</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Meta.html#Lean.MonadNameGenerator\">MonadNameGenerator</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span></div></div>"}]}