{"name":"Lean.Elab.PreDefinition.Structural.Basic","instances":[{"typeNames":["Lean.Elab.Structural.M"],"name":"Lean.Elab.Structural.instInhabitedM","className":"Inhabited"}],"imports":["Lean.Meta.Basic","Lean.Meta.ForEachExpr"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L89-L98","name":"Lean.Elab.Structural.Positions.mapMwith","line":89,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.mapMwith","doc":"Let `positions.size = ys.size` and `positions.numIndices = xs.size`. Maps `f` over each `y` in `ys`,\nalso passing in those elements `xs` that belong to that are those elements of `xs` that belong to\n`y` according to `positions`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.mapMwith\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">mapMwith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_4</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">positions</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">γ</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L79-L87","name":"Lean.Elab.Structural.Positions.groupAndSort","line":79,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.groupAndSort","doc":"Groups the `xs` by their `f` value, and puts these groups into the order given by `ys`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.groupAndSort\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">groupAndSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L69-L77","name":"Lean.Elab.Structural.Positions.inverse","line":69,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.inverse","doc":"`positions.inverse[k] = i` means that function `i` has type k\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.inverse\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">inverse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">positions</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L63-L67","name":"Lean.Elab.Structural.Positions.numIndices","line":63,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.numIndices","doc":"The number of indices in the array.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.numIndices\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">numIndices</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">positions</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L43-L61","name":"Lean.Elab.Structural.Positions","line":43,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions","doc":"Lets say we have `n` mutually recursive functions whose recursive arguments are from a group\nof `m` mutually inductive data types. This mapping does not have to be one-to-one: for one type\nthere can be zero, one or more functions. We use the logic in the `FunPacker` modules to combine\nthe bodies (and motives) of multiple such functions.\n\nTherefore we have to take the `n` functions, group them by their recursive argument's type,\nand for each such type, keep track of the order of the functions.\n\nWe represent these positions as an `Array (Array Nat)`. We have that\n\n* `positions.size = indInfo.numTypeFormers`\n* `positions.flatten` is a permutation of `[0:n]`, so each of the `n` functions has exactly one\n  position, and each position refers to one of the `n` functions.\n* if `k ∈ positions[i]` then the recursive argument of function `k` is has type `indInfo.all[i]`\n  (or corresponding nested inductive type)\n\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L28-L40","name":"Lean.Elab.Structural.recArgHasLooseBVarsAt","line":28,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.recArgHasLooseBVarsAt","doc":"Return true iff `e` contains an application `recFnName .. t ..` where the term `t` is\nthe argument we are trying to recurse on, and it contains loose bound variables.\n\nWe use this test to decide whether we should process a matcher-application as a regular\napplication or not. That is, whether we should push the `below` argument should be affected by the matcher or not.\nIf `e` does not contain an application of the form `recFnName .. t ..`, then we know\nthe recursion doesn't depend on any pattern variable in this matcher.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.recArgHasLooseBVarsAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">recArgHasLooseBVarsAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recFnName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recArgPos</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L25-L26","name":"Lean.Elab.Structural.run","line":25,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.run","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.run\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a> := <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\">{</a> <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\">}</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L22-L23","name":"Lean.Elab.Structural.instInhabitedM","line":22,"kind":"instance","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.instInhabitedM","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.instInhabitedM\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">instInhabitedM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\">M</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L20-L20","name":"Lean.Elab.Structural.M","line":20,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L18-L18","name":"Lean.Elab.Structural.State.addMatchers","line":18,"kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.addMatchers","doc":"As part of the inductive predicates case, we keep adding more and more discriminants from the\nlocal context and build up a bigger matcher application until we reach a fixed point.\nAs a side-effect, this creates matchers. Here we capture all these side-effects, because\nthe construction rolls back any changes done to the environment and the side-effects\nneed to be replayed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.addMatchers\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span>.<span class=\"name\">addMatchers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L12-L12","name":"Lean.Elab.Structural.State.mk","line":12,"kind":"ctor","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">addMatchers</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L12-L18","name":"Lean.Elab.Structural.State","line":12,"kind":"structure","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}