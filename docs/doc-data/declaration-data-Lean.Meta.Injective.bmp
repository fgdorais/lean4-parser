{"name":"Lean.Meta.Injective","instances":[],"imports":["Lean.Meta.Transform","Lean.Meta.Tactic.Injection","Lean.Meta.Tactic.Apply","Lean.Meta.Tactic.Refl","Lean.Meta.Tactic.Cases","Lean.Meta.Tactic.Subst","Lean.Meta.Tactic.Simp.Types","Lean.Meta.Tactic.Assumption"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L180-L195","name":"Lean.Meta.mkInjectiveTheorems","line":180,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveTheorems","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveTheorems\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkInjectiveTheorems</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L175-L178","name":"Lean.Meta.genInjectivity","line":175,"kind":"opaque","docLink":"./Lean/Meta/Injective.html#Lean.Meta.genInjectivity","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.genInjectivity\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">genInjectivity</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L143-L144","name":"Lean.Meta.mkInjectiveEqTheoremNameFor","line":143,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveEqTheoremNameFor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveEqTheoremNameFor\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkInjectiveEqTheoremNameFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctorName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L128-L129","name":"Lean.Meta.mkInjectiveTheoremNameFor","line":128,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveTheoremNameFor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.mkInjectiveTheoremNameFor\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkInjectiveTheoremNameFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctorName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L58-L61","name":"Lean.Meta.occursOrInType.go","line":58,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.occursOrInType.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.occursOrInType.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">occursOrInType</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">s</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L35-L61","name":"Lean.Meta.occursOrInType","line":35,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.occursOrInType","doc":"Returns true if `e` occurs either in `t`, or in the type of a sub-expression of `t`.\nConsider the following example:\n```lean\ninductive Tyₛ : Type (u+1)\n| SPi : (T : Type u) -> (T -> Tyₛ) -> Tyₛ\n\ninductive Tmₛ.{u} :  Tyₛ.{u} -> Type (u+1)\n| app : Tmₛ (.SPi T A) -> (arg : T) -> Tmₛ (A arg)```\n```\nWhen looking for fixed arguments in `Tmₛ.app`, if we only consider occurrences in the term `Tmₛ (A arg)`,\n`T` is considered non-fixed despite the fact that `A : T -> Tyₛ`.\nThis leads to an ill-typed injectivity theorem signature:\n```lean\ntheorem Tmₛ.app.inj {T : Type u} {A : T → Tyₛ} {a : Tmₛ (Tyₛ.SPi T A)} {arg : T} {T_1 : Type u} {a_1 : Tmₛ (Tyₛ.SPi T_1 A)} :\nTmₛ.app a arg = Tmₛ.app a_1 arg →\n  T = T_1 ∧ HEq a a_1 := fun x => Tmₛ.noConfusion x fun T_eq A_eq a_eq arg_eq => eq_of_heq a_eq\n```\nInstead of checking the type of every subterm, we only need to check the type of free variables, since free variables introduced in\nthe constructor may only appear in the type of other free variables introduced after them.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.occursOrInType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">occursOrInType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Injective.lean#L27-L32","name":"Lean.Meta.elimOptParam","line":27,"kind":"def","docLink":"./Lean/Meta/Injective.html#Lean.Meta.elimOptParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Injective.html#Lean.Meta.elimOptParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">elimOptParam</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"}]}