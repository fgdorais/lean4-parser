{"name":"Lean.Meta.Tactic.Replace","instances":[],"imports":["Lean.Util.ForEachExpr","Lean.Elab.InfoTree.Main","Lean.Meta.AppBuilder","Lean.Meta.MatchUtil","Lean.Meta.Tactic.Util","Lean.Meta.Tactic.Revert","Lean.Meta.Tactic.Intro","Lean.Meta.Tactic.Clear","Lean.Meta.Tactic.Assert"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L208-L217","name":"Lean.MVarId.modifyTargetEqLHS","line":208,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.modifyTargetEqLHS","doc":"Modify `mvarId` target type left-hand-side using `f`.\nThrow an error if target type is not an equality.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.modifyTargetEqLHS\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">modifyTargetEqLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L200-L206","name":"Lean.MVarId.modifyTarget","line":200,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.modifyTarget","doc":"Modify `mvarId` target type using `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.modifyTarget\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">modifyTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L173-L198","name":"Lean.MVarId.changeLocalDecl","line":173,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.changeLocalDecl","doc":"Replaces the type of the free variable `fvarId` with `typeNew`.\n\nIf `checkDefEq` is `true` then an error is thrown if `typeNew` is not definitionally\nequal to the type of `fvarId`. Otherwise this function assumes `typeNew` and the type\nof `fvarId` are definitionally equal.\n\nThis function is the same as `Lean.MVarId.changeLocalDecl` but makes sure to push substitution\ninformation into the info tree.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.changeLocalDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">changeLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L131-L171","name":"Lean.MVarId.withReverted","line":131,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.withReverted","doc":"Executes the revert/intro pattern, running the continuation `k` after temporarily reverting\nthe given local variables from the local context of the metavariable `mvarId`,\nand then re-introducing the local variables specified by `k`.\n\n- `mvarId` is the goal metavariable to operate on.\n- `fvarIds` is an array of `fvarIds` to revert in the order specified.\n  An error is thrown if they cannot be reverted in order.\n- `clearAuxDeclsInsteadOfRevert` is configuration passed to `Lean.MVarId.revert`.\n- `k` is the continuation run once the local variables have been reverted.\n  It is provided `mvarId` after the requested variables have been reverted along with the array of reverted variables.\n  This array always contains `fvarIds`, but it may contain additional variables that were reverted due to dependencies.\n  The continuation returns a value, a new goal, and an _aliasing array_.\n\nOnce `k` has completed, one variable is introduced per entry in the aliasing array.\n* If the entry is `none`, the variable is just introduced.\n* If the entry is `some fv` (where `fv` is a variable from `fvarIds`),\n  the variable is introduced and then recorded as an alias of `fv` in the info tree.\n  This for example causes the unused variable linter as seeing `fv` and this newly introduced variable as being \"the same\".\n\nFor example, if `k` leaves all the reverted variables in the same order,\nhaving it return `fvars.map .some` as the aliasing array causes those variables to be re-introduced and aliased\nto the original local variables.\n\nReturns the value returned by `k` along with the resulting goal after variable introduction.\n\nSee `Lean.MVarId.changeLocalDecl` for an example. The motivation is that to work on a local variable,\nyou need to move it into the goal, alter the goal, and then bring it back into the local context,\nall while keeping track of any other local variables that depend on this one.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.withReverted\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">withReverted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clearAuxDeclsInsteadOfRevert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L119-L129","name":"Lean.MVarId.change","line":119,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.change","doc":"Replace the target type of `mvarId` with `typeNew`.\nIf `checkDefEq = false`, this method assumes that `typeNew` is definitionally equal to the current target type.\nIf `checkDefEq = true`, throw an error if `typeNew` is not definitionally equal to the current target type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.change\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">change</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">targetNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L101-L117","name":"Lean.MVarId.replaceLocalDeclDefEq","line":101,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceLocalDeclDefEq","doc":"Replaces the type of `fvarId` at `mvarId` with `typeNew`.\nRemark: this method assumes that `typeNew` is definitionally equal to the current type of `fvarId`.\n\nIf `typeNew` is equal to current type of `fvarId`, then returns `mvarId` unchanged.\nUses `Expr.equal` for the comparison so that it is possible to update binder names, etc., which are user-visible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceLocalDeclDefEq\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">replaceLocalDeclDefEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L83-L99","name":"Lean.MVarId.replaceLocalDecl","line":83,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceLocalDecl","doc":"Replace type of the local declaration with id `fvarId` with one with the same user-facing name, but with type `typeNew`.\nThis method assumes `eqProof` is a proof that the type of `fvarId` is equal to `typeNew`.\nThis tactic actually adds a new declaration and (tries to) clear the old one.\nIf the old one cannot be cleared, then at least its user-facing name becomes inaccessible.\n\nThe new local declaration is inserted at the soonest point after `fvarId` at which it is\nwell-formed. That is, if `typeNew` involves declarations which occur later than `fvarId` in the\nlocal context, the new local declaration will be inserted immediately after the latest-occurring\none. Otherwise, it will be inserted immediately after `fvarId`.\n\nNote: `replaceLocalDecl` should not be used when unassigned pending mvars might be present in\n`typeNew`, as these may later be synthesized to fvars which occur after `fvarId` (by e.g.\n`Term.withSynthesize` or `Term.synthesizeSyntheticMVars`) .\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceLocalDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">replaceLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew </span><span class=\"fn\">eqProof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Assert.html#Lean.Meta.AssertAfterResult\">Meta.AssertAfterResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L35-L57","name":"Lean.MVarId.replaceTargetDefEq","line":35,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceTargetDefEq","doc":"Converts the given goal `Ctx |- target` into `Ctx |- targetNew`. It assumes the goals are definitionally equal.\nWe use the proof term\n```\n@id target mvarNew\n```\nto create a checkpoint.\n\nIf `targetNew` is equal to `target`, then returns `mvarId` unchanged.\nUses `Expr.equal` for the comparison so that it is possible to update binder names, etc., which are user-visible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceTargetDefEq\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">replaceTargetDefEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">targetNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/Replace.lean#L19-L33","name":"Lean.MVarId.replaceTargetEq","line":19,"kind":"def","docLink":"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceTargetEq","doc":"Convert the given goal `Ctx |- target` into `Ctx |- targetNew` using an equality proof `eqProof : target = targetNew`.\nIt assumes `eqProof` has type `target = targetNew` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Replace.html#Lean.MVarId.replaceTargetEq\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">replaceTargetEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">targetNew </span><span class=\"fn\">eqProof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"}]}