{"name":"Std.Sync.Mutex","instances":[{"typeNames":["Std.BaseMutex"],"name":"Std.instNonemptyBaseMutex","className":"Nonempty"},{"typeNames":["Std.Condvar"],"name":"Std.instNonemptyCondvar","className":"Nonempty"},{"typeNames":["Std.Mutex"],"name":"Std.instNonemptyMutex","className":"Nonempty"},{"typeNames":["Std.Mutex","Std.BaseMutex"],"name":"Std.instCoeOutMutexBaseMutex","className":"CoeOut"}],"imports":["Std.Sync.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L157-L170","name":"Std.Mutex.atomicallyOnce","line":157,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Mutex.atomicallyOnce","doc":"`mutex.atomicallyOnce condvar pred k` runs `k`, waiting on `condvar` until `pred` returns true.\nBoth `k` and `pred` have access to the mutex's state.\n\nCalling `mutex.atomicallyOnce` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.atomicallyOnce\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">atomicallyOnce</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pred</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L139-L155","name":"Std.Mutex.tryAtomically","line":139,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Mutex.tryAtomically","doc":"`mutex.tryAtomically k` tries to lock `mutex` and runs `k` on it if it succeeds. On success the\nreturn value of `k` is returned as `some`, on failure `none` is returned.\n\nThis function does not block on the `mutex`. Additionally calling `mutex.tryAtomically` while\nalready holding the underlying `BaseMutex` in the same thread is undefined behavior. If this is\nunavoidable in your code, consider using `RecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.tryAtomically\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">tryAtomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">β</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L125-L137","name":"Std.Mutex.atomically","line":125,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Mutex.atomically","doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex.\n\nCalling `mutex.atomically` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.atomically\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">atomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L121-L123","name":"Std.Mutex.new","line":121,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Mutex.new","doc":"Creates a new mutex. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">new</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L119-L119","name":"Std.instCoeOutMutexBaseMutex","line":119,"kind":"instance","docLink":"./Std/Sync/Mutex.html#Std.instCoeOutMutexBaseMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instCoeOutMutexBaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instCoeOutMutexBaseMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeOut\">CoeOut</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span>)</span> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L117-L117","name":"Std.instNonemptyMutex","line":117,"kind":"instance","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α✝</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α✝</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α✝</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L116-L116","name":"Std.Mutex.mutex","line":116,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Mutex.mutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.mutex\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">mutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L108-L117","name":"Std.Mutex","line":108,"kind":"structure","docLink":"./Std/Sync/Mutex.html#Std.Mutex","doc":"Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L102-L106","name":"Std.Condvar.waitUntil","line":102,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Condvar.waitUntil","doc":"Waits on the condition variable until the predicate is true. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.waitUntil\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">waitUntil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pred</span> : <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L98-L100","name":"Std.Condvar.notifyAll","line":98,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.Condvar.notifyAll","doc":"Wakes up all other threads executing `wait`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.notifyAll\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">notifyAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L94-L96","name":"Std.Condvar.notifyOne","line":94,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.Condvar.notifyOne","doc":"Wakes up a single other thread executing `wait`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.notifyOne\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">notifyOne</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L90-L92","name":"Std.Condvar.wait","line":90,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.Condvar.wait","doc":"Waits until another thread calls `notifyOne` or `notifyAll`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.wait\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">wait</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L86-L88","name":"Std.Condvar.new","line":86,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.Condvar.new","doc":"Creates a new condition variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.new\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L84-L84","name":"Std.instNonemptyCondvar","line":84,"kind":"instance","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyCondvar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyCondvar\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyCondvar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L61-L82","name":"Std.Condvar","line":61,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.Condvar","doc":"Condition variable, a synchronization primitive to be used with a `BaseMutex` or `Mutex`.\n\nThe thread that wants to modify the shared variable must:\n1. Lock the `BaseMutex` or `Mutex`\n2. Work on the shared variable\n3. Call `Condvar.notifyOne` or `Condvar.notifyAll` after it is done. Note that this may be done\n   before or after the mutex is unlocked.\n\nIf working with a `Mutex` the thread that waits on the `Condvar` can use `Mutex.atomicallyOnce`\nto wait until a condition is true. If working with a `BaseMutex` it must:\n1. Lock the `BaseMutex`.\n2. Do one of the following:\n  - Use `Condvar.waitUntil` to (potentially repeatedly wait) on the condition variable until\n     the condition is true.\n  - Implement the waiting manually by:\n    1. Checking the condition\n    2. Calling `Condvar.wait` which releases the `BaseMutex` and suspends execution until the\n       condition variable is notified.\n    3. Check the condition and resume waiting if not satisfied.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L49-L57","name":"Std.BaseMutex.unlock","line":49,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.unlock","doc":"Unlocks a `BaseMutex`.\n\nThe current thread must have already locked the mutex.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.unlock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">unlock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L36-L47","name":"Std.BaseMutex.tryLock","line":36,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.tryLock","doc":"Attempts to lock a `BaseMutex`. If the mutex is not available return `false`, otherwise lock it and\nreturn `true`.\n\nThis function does not block.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.tryLock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">tryLock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L26-L34","name":"Std.BaseMutex.lock","line":26,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.lock","doc":"Locks a `BaseMutex`.  Waits until no other thread has locked the mutex.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.lock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">lock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L22-L24","name":"Std.BaseMutex.new","line":22,"kind":"opaque","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.new","doc":"Creates a new `BaseMutex`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L20-L20","name":"Std.instNonemptyBaseMutex","line":20,"kind":"instance","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyBaseMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyBaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyBaseMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/Mutex.lean#L13-L18","name":"Std.BaseMutex","line":13,"kind":"def","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex","doc":"Mutual exclusion primitive (a lock).\n\nIf you want to guard shared state, use `Mutex α` instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}