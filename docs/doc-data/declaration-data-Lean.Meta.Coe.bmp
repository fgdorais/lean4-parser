{"name":"Lean.Meta.Coe","instances":[],"imports":["Lean.Meta.Transform","Lean.Meta.SynthInstance","Lean.Meta.AppBuilder"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L201-L212","name":"Lean.Meta.coerce?","line":201,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerce?","doc":"Coerces `expr` to the type `expectedType`.\nReturns `.some coerced` on successful coercion,\n`.none` if the expression cannot by coerced to that type,\nor `.undef` if we need more metavariable assignments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerce?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerce?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L96-L199","name":"Lean.Meta.coerceMonadLift?","line":96,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceMonadLift?","doc":"Try coercions and monad lifts to make sure `e` has type `expectedType`.\n\nIf `expectedType` is of the form `n β`, we try monad lifts and other extensions.\n\nExtensions for monads.\n\n1. Try to unify `n` and `m`. If it succeeds, then we use\n  ```\n  coeM {m : Type u → Type v} {α β : Type u} [∀ a, CoeT α a β] [Monad m] (x : m α) : m β\n  ```\n  `n` must be a `Monad` to use this one.\n\n2. If there is monad lift from `m` to `n` and we can unify `α` and `β`, we use\n  ```\n  liftM : ∀ {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [self : MonadLiftT m n] {α : Type u_1}, m α → n α\n  ```\n  Note that `n` may not be a `Monad` in this case. This happens quite a bit in code such as\n  ```\n  def g (x : Nat) : IO Nat := do\n    IO.println x\n    pure x\n\n  def f {m} [MonadLiftT IO m] : m Nat :=\n    g 10\n\n  ```\n\n3. If there is a monad lift from `m` to `n` and a coercion from `α` to `β`, we use\n  ```\n  liftCoeM {m : Type u → Type v} {n : Type u → Type w} {α β : Type u} [MonadLiftT m n] [∀ a, CoeT α a β] [Monad n] (x : m α) : n β\n  ```\n\nNote that approach 3 does not subsume 1 because it is only applicable if there is a coercion from `α` to `β` for all values in `α`.\nThis is not the case for example for `pure $ x > 0` when the expected type is `IO Bool`. The given type is `IO Prop`, and\nwe only have a coercion from decidable propositions.  Approach 1 works because it constructs the coercion `CoeT (m Prop) (pure $ x > 0) (m Bool)`\nusing the instance `pureCoeDepProp`.\n\nNote that, approach 2 is more powerful than `tryCoe`.\nRecall that type class resolution never assigns metavariables created by other modules.\nNow, consider the following scenario\n```lean\ndef g (x : Nat) : IO Nat := ...\ndeg h (x : Nat) : StateT Nat IO Nat := do\nv ← g x;\nIO.Println v;\n...\n```\nLet's assume there is no other occurrence of `v` in `h`.\nThus, we have that the expected of `g x` is `StateT Nat IO ?α`,\nand the given type is `IO Nat`. So, even if we add a coercion.\n```\ninstance {α m n} [MonadLiftT m n] {α} : Coe (m α) (n α) := ...\n```\nIt is not applicable because TC would have to assign `?α := Nat`.\nOn the other hand, TC can easily solve `[MonadLiftT IO (StateT Nat IO)]`\nsince this goal does not contain any metavariables. And then, we\nconvert `g x` into `liftM $ g x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceMonadLift?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceMonadLift?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L88-L94","name":"Lean.Meta.isMonadApp","line":88,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isMonadApp","doc":"Return `true` if `type` is of the form `m α` where `m` is a `Monad`.\nNote that we reduce `type` using transparency `[reducible]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isMonadApp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isMonadApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L81-L86","name":"Lean.Meta.isTypeApp?","line":81,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isTypeApp?","doc":"Return `some (m, α)` if `type` can be reduced to an application of the form `m α` using `[reducible]` transparency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isTypeApp?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeApp?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L68-L79","name":"Lean.Meta.coerceToSort?","line":68,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToSort?","doc":"Coerces `expr` to a type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceToSort?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceToSort?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L55-L66","name":"Lean.Meta.coerceToFunction?","line":55,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToFunction?","doc":"Coerces `expr` to a function type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceToFunction?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceToFunction?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L40-L53","name":"Lean.Meta.coerceSimple?","line":40,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceSimple?","doc":"Coerces `expr` to `expectedType` using `CoeT`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceSimple?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceSimple?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L35-L38","name":"Lean.Meta.autoLift","line":35,"kind":"opaque","docLink":"./Lean/Meta/Coe.html#Lean.Meta.autoLift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.autoLift\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">autoLift</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L23-L33","name":"Lean.Meta.expandCoe","line":23,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.expandCoe","doc":"Expand coercions occurring in `e` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.expandCoe\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">expandCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L16-L21","name":"Lean.Meta.isCoeDecl","line":16,"kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isCoeDecl","doc":"Return true iff `declName` is one of the auxiliary definitions/projections\nused to implement coercions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isCoeDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isCoeDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Coe.lean#L13-L14","name":"Lean.Meta.coeDeclAttr","line":13,"kind":"opaque","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coeDeclAttr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coeDeclAttr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coeDeclAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Attributes.html#Lean.TagAttribute\">TagAttribute</a></div></div>"}]}