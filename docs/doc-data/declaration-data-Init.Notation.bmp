{"name":"Init.Notation","instances":[{"typeNames":["Lean.TSyntax","Lean.Syntax"],"name":"Lean.instCoeOutTSyntaxSyntax","className":"CoeOut"},{"typeNames":["Lean.SyntaxNodeKind","Lean.SyntaxNodeKinds"],"name":"Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","className":"Coe"},{"typeNames":["Lean.Syntax","Lean.TSyntax"],"name":"Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"}],"imports":["Init.Prelude","Init.Coe"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L837-L844","name":"Lean.Parser.commandUnseal__","line":837,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.commandUnseal__","doc":"The `unseal foo` command ensures that the definition of `foo` is unsealed, meaning it is marked as `[semireducible]`, the\ndefault reducibility setting. This command is useful when you need to allow some level of reduction of `foo` in proofs.\n\nFunctionally, `unseal foo` is equivalent to `attribute [local semireducible] foo`.\nApplying this attribute makes `foo` semireducible only within the local scope.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.commandUnseal__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">commandUnseal__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L827-L835","name":"Lean.Parser.commandSeal__","line":827,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.commandSeal__","doc":"The `seal foo` command ensures that the definition of `foo` is sealed, meaning it is marked as `[irreducible]`.\nThis command is particularly useful in contexts where you want to prevent the reduction of `foo` in proofs.\n\nIn terms of functionality, `seal foo` is equivalent to `attribute [local irreducible] foo`.\nThis attribute specifies that `foo` should be treated as irreducible only within the local scope,\nwhich helps in maintaining the desired abstraction level without affecting global settings.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.commandSeal__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">commandSeal__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L824-L825","name":"Lean.Parser.discrTreeSimpKeyCmd","line":824,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.discrTreeSimpKeyCmd","doc":"`#discr_tree_key  t` prints the discrimination tree keys for a term `t` (or, if it is a single identifier, the type of that constant).\nIt uses the default configuration for generating keys.\n\nFor example,\n```\n#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))\n-- bar _ (@OfNat.ofNat Nat _ _)\n\n#discr_tree_simp_key Nat.add_assoc\n-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _\n```\n\n`#discr_tree_simp_key` is similar to `#discr_tree_key`, but treats the underlying type\nas one of a simp lemma, i.e. transforms it into an equality and produces the key of the\nleft-hand side.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.discrTreeSimpKeyCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">discrTreeSimpKeyCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L805-L822","name":"Lean.Parser.discrTreeKeyCmd","line":805,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.discrTreeKeyCmd","doc":"`#discr_tree_key  t` prints the discrimination tree keys for a term `t` (or, if it is a single identifier, the type of that constant).\nIt uses the default configuration for generating keys.\n\nFor example,\n```\n#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))\n-- bar _ (@OfNat.ofNat Nat _ _)\n\n#discr_tree_simp_key Nat.add_assoc\n-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _\n```\n\n`#discr_tree_simp_key` is similar to `#discr_tree_key`, but treats the underlying type\nas one of a simp lemma, i.e. transforms it into an equality and produces the key of the\nleft-hand side.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.discrTreeKeyCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">discrTreeKeyCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L794-L803","name":"Lean.Parser.timeCmd","line":794,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.timeCmd","doc":"Time the elaboration of a command, and print the result (in milliseconds).\n\nExample usage:\n```\nset_option maxRecDepth 100000 in\n#time example : (List.range 500).length = 500 := rfl\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.timeCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">timeCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L789-L792","name":"Lean.Parser.checkSimpFailure","line":789,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.checkSimpFailure","doc":"`#check_simp t !~>` checks `simp` fails on reducing `t`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.checkSimpFailure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">checkSimpFailure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L784-L787","name":"Lean.Parser.checkSimp","line":784,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.checkSimp","doc":"`#check_simp t ~> r` checks `simp` reduces `t` to `r`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.checkSimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">checkSimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L778-L782","name":"Lean.Parser.checkTacticFailure","line":778,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.checkTacticFailure","doc":"`#check_tactic_failure t by tac` runs the tactic `tac`\non a goal with `t` and verifies it fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.checkTacticFailure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">checkTacticFailure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L771-L776","name":"Lean.Parser.checkTactic","line":771,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.checkTactic","doc":"`#check_tactic t ~> r by commands` runs the tactic sequence `commands`\non a goal with `t` and sees if the resulting expression has reduced it\nto `r`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.checkTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">checkTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L761-L767","name":"Lean.setPremiseSelectorCmd","line":761,"kind":"def","docLink":"./Init/Notation.html#Lean.setPremiseSelectorCmd","doc":"Specify a premise selection engine.\nNote that Lean does not ship a default premise selection engine,\nso this is only useful in conjunction with a downstream package which provides one.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.setPremiseSelectorCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">setPremiseSelectorCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L754-L759","name":"Lean.infoTreesCmd","line":754,"kind":"def","docLink":"./Init/Notation.html#Lean.infoTreesCmd","doc":"Format and print the info trees for a given command.\nThis is mostly useful for debugging info trees.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.infoTreesCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">infoTreesCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L683-L752","name":"Lean.guardMsgsCmd","line":683,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsCmd","doc":"`/-- ... -/ #guard_msgs in cmd` captures the messages generated by the command `cmd`\nand checks that they match the contents of the docstring.\n\nBasic example:\n```lean\n/--\nerror: unknown identifier 'x'\n-/\n#guard_msgs in\nexample : α := x\n```\nThis checks that there is such an error and then consumes the message.\n\nBy default, the command captures all messages, but the filter condition can be adjusted.\nFor example, we can select only warnings:\n```lean\n/--\nwarning: declaration uses 'sorry'\n-/\n#guard_msgs(warning) in\nexample : α := sorry\n```\nor only errors\n```lean\n#guard_msgs(error) in\nexample : α := sorry\n```\nIn the previous example, since warnings are not captured there is a warning on `sorry`.\nWe can drop the warning completely with\n```lean\n#guard_msgs(error, drop warning) in\nexample : α := sorry\n```\n\nIn general, `#guard_msgs` accepts a comma-separated list of configuration clauses in parentheses:\n```\n#guard_msgs (configElt,*) in cmd\n```\nBy default, the configuration list is `(all, whitespace := normalized, ordering := exact)`.\n\nMessage filters (processed in left-to-right order):\n- `info`, `warning`, `error`: capture messages with the given severity level.\n- `all`: capture all messages (the default).\n- `drop info`, `drop warning`, `drop error`: drop messages with the given severity level.\n- `drop all`: drop every message.\n\nWhitespace handling (after trimming leading and trailing whitespace):\n- `whitespace := exact` requires an exact whitespace match.\n- `whitespace := normalized` converts all newline characters to a space before matching\n  (the default). This allows breaking long lines.\n- `whitespace := lax` collapses whitespace to a single space before matching.\n\nMessage ordering:\n- `ordering := exact` uses the exact ordering of the messages (the default).\n- `ordering := sorted` sorts the messages in lexicographic order.\n  This helps with testing commands that are non-deterministic in their ordering.\n\nFor example, `#guard_msgs (error, drop all) in cmd` means to check warnings and drop\neverything else.\n\nThe command elaborator has special support for `#guard_msgs` for linting.\nThe `#guard_msgs` itself wants to capture linter warnings,\nso it elaborates the command it is attached to as if it were a top-level command.\nHowever, the command elaborator runs linters for *all* top-level commands,\nwhich would include `#guard_msgs` itself, and would cause duplicate and/or uncaptured linter warnings.\nThe top-level command elaborator only runs the linters if `#guard_msgs` is not present.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L681-L681","name":"Lean.guardMsgsSpec","line":681,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsSpec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L678-L678","name":"Lean.guardMsgsSpecElt","line":678,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsSpecElt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsSpecElt\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsSpecElt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L669-L675","name":"Lean.guardMsgsOrdering","line":669,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsOrdering","doc":"Message ordering for `#guard_msgs`:\n- `ordering := exact` uses the exact ordering of the messages (the default).\n- `ordering := sorted` sorts the messages in lexicographic order.\n  This helps with testing commands that are non-deterministic in their ordering.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsOrdering\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsOrdering</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L667-L667","name":"Lean.guardMsgsOrderingArg","line":667,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsOrderingArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsOrderingArg\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsOrderingArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L656-L664","name":"Lean.guardMsgsWhitespace","line":656,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsWhitespace","doc":"Whitespace handling for `#guard_msgs`:\n- `whitespace := exact` requires an exact whitespace match.\n- `whitespace := normalized` converts all newline characters to a space before matching\n  (the default). This allows breaking long lines.\n- `whitespace := lax` collapses whitespace to a single space before matching.\nIn all cases, leading and trailing whitespace is trimmed before matching.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsWhitespace\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsWhitespace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L654-L654","name":"Lean.guardMsgsWhitespaceArg","line":654,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsWhitespaceArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsWhitespaceArg\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsWhitespaceArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L643-L651","name":"Lean.guardMsgsFilter","line":643,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsFilter","doc":"A message filter specification for `#guard_msgs`.\n- `info`, `warning`, `error`: capture messages with the given severity level.\n- `all`: capture all messages (the default).\n- `drop info`, `drop warning`, `drop error`: drop messages with the given severity level.\n- `drop all`: drop every message.\nThese filters are processed in left-to-right order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsFilter\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsFilter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L627-L641","name":"Lean.reduceCmd","line":627,"kind":"def","docLink":"./Init/Notation.html#Lean.reduceCmd","doc":"`#reduce <expression>` reduces the expression `<expression>` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval <expression>` for simple evaluation/execution\nof expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.reduceCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">reduceCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L625-L625","name":"Lean.guardMsgsFilterSeverity","line":625,"kind":"def","docLink":"./Init/Notation.html#Lean.guardMsgsFilterSeverity","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.guardMsgsFilterSeverity\"><span class=\"name\">Lean</span>.<span class=\"name\">guardMsgsFilterSeverity</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L616-L622","name":"Lean.runMeta","line":616,"kind":"def","docLink":"./Init/Notation.html#Lean.runMeta","doc":"The `run_meta doSeq` command executes code in `MetaM Unit`.\nThis is the same as `#eval show MetaM Unit from do discard doSeq`.\n\n(This is effectively a synonym for `run_elab` since `MetaM` lifts to `TermElabM`.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.runMeta\"><span class=\"name\">Lean</span>.<span class=\"name\">runMeta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L610-L614","name":"Lean.runElab","line":610,"kind":"def","docLink":"./Init/Notation.html#Lean.runElab","doc":"The `run_elab doSeq` command executes code in `TermElabM Unit`.\nThis is the same as `#eval show TermElabM Unit from discard do doSeq`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.runElab\"><span class=\"name\">Lean</span>.<span class=\"name\">runElab</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L604-L608","name":"Lean.runCmd","line":604,"kind":"def","docLink":"./Init/Notation.html#Lean.runCmd","doc":"The `run_cmd doSeq` command executes code in `CommandElabM Unit`.\nThis is the same as `#eval show CommandElabM Unit from discard do doSeq`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.runCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">runCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L597-L602","name":"Lean.includeStr","line":597,"kind":"def","docLink":"./Init/Notation.html#Lean.includeStr","doc":"When `parent_dir` contains the current Lean file, `include_str \"path\" / \"to\" / \"file\"` becomes\na string literal with the contents of the file at `\"parent_dir\" / \"path\" / \"to\" / \"file\"`. If this\nfile cannot be read, elaboration fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.includeStr\"><span class=\"name\">Lean</span>.<span class=\"name\">includeStr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L592-L595","name":"Lean.builtin_command_code_action","line":592,"kind":"def","docLink":"./Init/Notation.html#Lean.builtin_command_code_action","doc":"Builtin command code action. See `command_code_action`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.builtin_command_code_action\"><span class=\"name\">Lean</span>.<span class=\"name\">builtin_command_code_action</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L578-L590","name":"Lean.command_code_action","line":578,"kind":"def","docLink":"./Init/Notation.html#Lean.command_code_action","doc":"This attribute marks a code action, which is used to suggest new tactics or replace existing ones.\n\n* `@[command_code_action kind]`: This is a code action which applies to applications of the command\n`kind` (a command syntax kind), which can replace the command or insert things before or after it.\n\n* `@[command_code_action kind₁ kind₂]`: shorthand for\n`@[command_code_action kind₁, command_code_action kind₂]`.\n\n* `@[command_code_action]`: This is a command code action that applies to all commands.\nUse sparingly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.command_code_action\"><span class=\"name\">Lean</span>.<span class=\"name\">command_code_action</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L571-L576","name":"Lean.Attr.coe","line":571,"kind":"def","docLink":"./Init/Notation.html#Lean.Attr.coe","doc":"The `@[coe]` attribute on a function (which should also appear in a\n`instance : Coe A B := ⟨myFn⟩` declaration) allows the delaborator to show\napplications of this function as `↑` when printing expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Attr.coe\"><span class=\"name\">Lean</span>.<span class=\"name\">Attr</span>.<span class=\"name\">coe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L559-L569","name":"Lean.deprecated","line":559,"kind":"def","docLink":"./Init/Notation.html#Lean.deprecated","doc":"The attribute `@[deprecated]` on a declaration indicates that the declaration\nis discouraged for use in new code, and/or should be migrated away from in\nexisting code. It may be removed in a future version of the library.\n\n* `@[deprecated myBetterDef]` means that `myBetterDef` is the suggested replacement.\n* `@[deprecated myBetterDef \"use myBetterDef instead\"]` allows customizing the deprecation message.\n* `@[deprecated (since := \"2024-04-21\")]` records when the deprecation was first applied.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.deprecated\"><span class=\"name\">Lean</span>.<span class=\"name\">deprecated</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L556-L557","name":"Lean.modCast","line":556,"kind":"def","docLink":"./Init/Notation.html#Lean.modCast","doc":"Normalize casts in an expression using the same method as the `norm_cast` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.modCast\"><span class=\"name\">Lean</span>.<span class=\"name\">modCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L553-L554","name":"Lean.withAnnotateTerm","line":553,"kind":"def","docLink":"./Init/Notation.html#Lean.withAnnotateTerm","doc":"`with_annotate_term stx e` annotates the lexical range of `stx : Syntax` with term info for `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.withAnnotateTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">withAnnotateTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L550-L551","name":"Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","line":550,"kind":"instance","docLink":"./Init/Notation.html#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil\"><span class=\"name\">Lean</span>.<span class=\"name\">instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`rawStx</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L544-L548","name":"Lean.rawStx.quot","line":544,"kind":"def","docLink":"./Init/Notation.html#Lean.rawStx.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.rawStx.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">rawStx</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L544-L548","name":"Lean.Parser.Category.rawStx","line":544,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.rawStx","doc":"Category for carrying raw syntax trees between macros; any content is printed as is by the pretty printer.\nThe only accepted parser for this category is an antiquotation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.rawStx\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rawStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L536-L542","name":"Lean.byElab","line":536,"kind":"def","docLink":"./Init/Notation.html#Lean.byElab","doc":"* The `by_elab doSeq` expression runs the `doSeq` as a `TermElabM Expr` to\n  synthesize the expression.\n* `by_elab fun expectedType? => do doSeq` receives the expected type (an `Option Expr`)\n  as well.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.byElab\"><span class=\"name\">Lean</span>.<span class=\"name\">byElab</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L532-L532","name":"termWithout_expected_type_","line":532,"kind":"def","docLink":"./Init/Notation.html#termWithout_expected_type_","doc":"`without_expected_type t` instructs Lean to elaborate `t` without an expected type.\nRecall that terms such as `match ... with ...` and `⟨...⟩` will postpone elaboration until\nexpected type is known. So, `without_expected_type` is not effective in this case.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#termWithout_expected_type_\"><span class=\"name\">termWithout_expected_type_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L519-L519","name":"«term{_:_//_}»","line":519,"kind":"def","docLink":"./Init/Notation.html#«term{_:_//_}»","doc":"All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : α // p x }` or `{ x // p x }`, contains all elements `x : α` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : α // p x }` is represented identically to `α`.\n\nThere is a coercion from `{ x : α // p x }` to `α`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List α`, `List { x : α // x ∈ xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term{_:_//_}»\"><span class=\"name\">«term{_:_//_}»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L507-L513","name":"«term_$__»","line":507,"kind":"def","docLink":"./Init/Notation.html#«term_$__»","doc":"Alternative syntax for `<|`. `f $ x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f $ g $ x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_$__»\"><span class=\"name\">«term_$__»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L497-L501","name":"«term_|>_»","line":497,"kind":"def","docLink":"./Init/Notation.html#«term_|>_»","doc":"Haskell-like pipe operator `|>`. `x |> f` means the same as the same as `f x`,\nand it chains such that `x |> f |> g` is interpreted as `g (f x)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_|&gt;_»\"><span class=\"name\">«term_|&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L486-L491","name":"«term_<|_»","line":486,"kind":"def","docLink":"./Init/Notation.html#«term_<|_»","doc":"Haskell-like pipe operator `<|`. `f <| x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;|_»\"><span class=\"name\">«term_&lt;|_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L479-L481","name":"boolIfThenElse","line":479,"kind":"def","docLink":"./Init/Notation.html#boolIfThenElse","doc":"The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#boolIfThenElse\"><span class=\"name\">boolIfThenElse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L461-L473","name":"termIfLet","line":461,"kind":"def","docLink":"./Init/Notation.html#termIfLet","doc":"`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat => t\n| _ => e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#termIfLet\"><span class=\"name\">termIfLet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L452-L454","name":"termIfThenElse","line":452,"kind":"def","docLink":"./Init/Notation.html#termIfThenElse","doc":"`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#termIfThenElse\"><span class=\"name\">termIfThenElse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L440-L442","name":"termDepIfThenElse","line":440,"kind":"def","docLink":"./Init/Notation.html#termDepIfThenElse","doc":"\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#termDepIfThenElse\"><span class=\"name\">termDepIfThenElse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L431-L435","name":"Lean.Parser.Tactic.caseArg","line":431,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Tactic.caseArg","doc":"A case tag argument has the form `tag x₁ ... xₙ`; it refers to tag `tag` and renames\nthe last `n` hypotheses to `x₁ ... xₙ`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Tactic.caseArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">caseArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L423-L427","name":"Lean.binderIdent","line":423,"kind":"def","docLink":"./Init/Notation.html#Lean.binderIdent","doc":"`binderIdent` matches an `ident` or a `_`. It is used for identifiers in binding\nposition, where `_` means that the value should be left unnamed and inaccessible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L404-L404","name":"«term_*>_»","line":404,"kind":"def","docLink":"./Init/Notation.html#«term_*>_»","doc":"Sequences the effects of two terms, discarding the value of the first. This function is usually\ninvoked via the `*>` operator.\n\nGiven `x : f α` and `y : f β`, `x *> y` runs `x`, then runs `y`, and finally returns the result of\n`y`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*>` in identifiers is `seqRight`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_*&gt;_»\"><span class=\"name\">«term_*&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L403-L403","name":"«term_<*_»","line":403,"kind":"def","docLink":"./Init/Notation.html#«term_<*_»","doc":"Sequences the effects of two terms, discarding the value of the second. This function is usually\ninvoked via the `<*` operator.\n\nGiven `x : f α` and `y : f β`, `x <* y` runs `x`, then runs `y`, and finally returns the result of\n`x`.\n\nThe evaluation of the second argument is delayed by wrapping it in a function, enabling\n“short-circuiting” behavior from `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<*` in identifiers is `seqLeft`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;*_»\"><span class=\"name\">«term_&lt;*_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L402-L402","name":"«term_<*>_»","line":402,"kind":"def","docLink":"./Init/Notation.html#«term_<*>_»","doc":"The implementation of the `<*>` operator.\n\nIn a monad, `mf <*> mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<*>` in identifiers is `seq`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;*&gt;_»\"><span class=\"name\">«term_&lt;*&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L401-L401","name":"«term_>>_»","line":401,"kind":"def","docLink":"./Init/Notation.html#«term_>>_»","doc":"`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `>>` in identifiers is `andThen`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&gt;&gt;_»\"><span class=\"name\">«term_&gt;&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L400-L400","name":"«term_<|>_»","line":400,"kind":"def","docLink":"./Init/Notation.html#«term_<|>_»","doc":"`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<|>` in identifiers is `orElse`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;|&gt;_»\"><span class=\"name\">«term_&lt;|&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L399-L399","name":"«term_>>=_»","line":399,"kind":"def","docLink":"./Init/Notation.html#«term_>>=_»","doc":"Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `>>=` in identifiers is `bind`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&gt;&gt;=_»\"><span class=\"name\">«term_&gt;&gt;=_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L398-L398","name":"«term_<$>_»","line":398,"kind":"def","docLink":"./Init/Notation.html#«term_<$>_»","doc":"Applies a function inside a functor. This is used to overload the `<$>` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<$>` in identifiers is `map`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;$&gt;_»\"><span class=\"name\">«term_&lt;$&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L397-L397","name":"«term_::_»","line":397,"kind":"def","docLink":"./Init/Notation.html#«term_::_»","doc":"The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_::_»\"><span class=\"name\">«term_::_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L391-L392","name":"«term_∉_»","line":391,"kind":"def","docLink":"./Init/Notation.html#«term_∉_»","doc":"`a ∉ b` is negated elementhood. It is notation for `¬ (a ∈ b)`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∉` in identifiers is `not_mem`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∉_»\"><span class=\"name\">«term_∉_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L390-L390","name":"«term_∈_»","line":390,"kind":"def","docLink":"./Init/Notation.html#«term_∈_»","doc":"The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∈_»\"><span class=\"name\">«term_∈_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L384-L384","name":"term!_","line":384,"kind":"def","docLink":"./Init/Notation.html#term!_","doc":"Boolean negation, also known as Boolean complement. `not x` can be written `!x`.\n\nThis is a function that maps the value `true` to `false` and the value `false` to `true`. The\npropositional connective is `Not : Prop → Prop`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `!` in identifiers is `not`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#term!_\"><span class=\"name\">term!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L383-L383","name":"«term_||_»","line":383,"kind":"def","docLink":"./Init/Notation.html#«term_||_»","doc":"Boolean “or”, also known as disjunction. `or x y` can be written `x || y`.\n\nThe corresponding propositional connective is `Or : Prop → Prop → Prop`, written with the `∨`\noperator.\n\nThe Boolean `or` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `true` then `y` is not evaluated at runtime.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `||` in identifiers is `or`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_||_»\"><span class=\"name\">«term_||_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L382-L382","name":"«term_&&_»","line":382,"kind":"def","docLink":"./Init/Notation.html#«term_&&_»","doc":"Boolean “and”, also known as conjunction. `and x y` can be written `x && y`.\n\nThe corresponding propositional connective is `And : Prop → Prop → Prop`, written with the `∧`\noperator.\n\nThe Boolean `and` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `false` then `y` is not evaluated at runtime.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&` in identifiers is `and`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&amp;&amp;_»\"><span class=\"name\">«term_&amp;&amp;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L372-L372","name":"«term¬_»","line":372,"kind":"def","docLink":"./Init/Notation.html#«term¬_»","doc":"`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term¬_»\"><span class=\"name\">«term¬_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L371-L371","name":"«term_∨_»","line":371,"kind":"def","docLink":"./Init/Notation.html#«term_∨_»","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∨_»\"><span class=\"name\">«term_∨_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L370-L370","name":"«term_\\/_»","line":370,"kind":"def","docLink":"./Init/Notation.html#«term_\\/_»","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `∨` over `\\/`)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_\\/_»\"><span class=\"name\">«term_\\/_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L369-L369","name":"«term_∧_»","line":369,"kind":"def","docLink":"./Init/Notation.html#«term_∧_»","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∧_»\"><span class=\"name\">«term_∧_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L368-L368","name":"«term_/\\_»","line":368,"kind":"def","docLink":"./Init/Notation.html#«term_/\\_»","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_/\\_»\"><span class=\"name\">«term_/\\_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L341-L341","name":"«term_==_»","line":341,"kind":"def","docLink":"./Init/Notation.html#«term_==_»","doc":"Boolean equality, notated as `a == b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `==` in identifiers is `beq`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_==_»\"><span class=\"name\">«term_==_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L340-L340","name":"«term_=_»","line":340,"kind":"def","docLink":"./Init/Notation.html#«term_=_»","doc":"The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_=_»\"><span class=\"name\">«term_=_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L339-L339","name":"«term_>_»","line":339,"kind":"def","docLink":"./Init/Notation.html#«term_>_»","doc":"`a > b` is an abbreviation for `b < a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `>` in identifiers is `gt`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&gt;_»\"><span class=\"name\">«term_&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L338-L338","name":"«term_≥_»","line":338,"kind":"def","docLink":"./Init/Notation.html#«term_≥_»","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≥` in identifiers is `ge`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_≥_»\"><span class=\"name\">«term_≥_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L337-L337","name":"«term_>=_»","line":337,"kind":"def","docLink":"./Init/Notation.html#«term_>=_»","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `>=` in identifiers is `ge` (prefer `≥` over `>=`)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&gt;=_»\"><span class=\"name\">«term_&gt;=_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L336-L336","name":"«term_<_»","line":336,"kind":"def","docLink":"./Init/Notation.html#«term_<_»","doc":"The less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;_»\"><span class=\"name\">«term_&lt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L335-L335","name":"«term_≤_»","line":335,"kind":"def","docLink":"./Init/Notation.html#«term_≤_»","doc":"The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_≤_»\"><span class=\"name\">«term_≤_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L334-L334","name":"«term_<=_»","line":334,"kind":"def","docLink":"./Init/Notation.html#«term_<=_»","doc":"The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<=` in identifiers is `le` (prefer `≤` over `<=`)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;=_»\"><span class=\"name\">«term_&lt;=_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L296-L296","name":"«term~~~_»","line":296,"kind":"def","docLink":"./Init/Notation.html#«term~~~_»","doc":"The implementation of `~~~a : α`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `~~~` in identifiers is `not`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term~~~_»\"><span class=\"name\">«term~~~_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L295-L295","name":"«term-_»","line":295,"kind":"def","docLink":"./Init/Notation.html#«term-_»","doc":"`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term-_»\"><span class=\"name\">«term-_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L294-L294","name":"«term_++_»","line":294,"kind":"def","docLink":"./Init/Notation.html#«term_++_»","doc":"`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_++_»\"><span class=\"name\">«term_++_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L293-L293","name":"«term_^_»","line":293,"kind":"def","docLink":"./Init/Notation.html#«term_^_»","doc":"`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_^_»\"><span class=\"name\">«term_^_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L292-L292","name":"«term_>>>_»","line":292,"kind":"def","docLink":"./Init/Notation.html#«term_>>>_»","doc":"`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `>>>` in identifiers is `shiftRight`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&gt;&gt;&gt;_»\"><span class=\"name\">«term_&gt;&gt;&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L291-L291","name":"«term_<<<_»","line":291,"kind":"def","docLink":"./Init/Notation.html#«term_<<<_»","doc":"`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<<<` in identifiers is `shiftLeft`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&lt;&lt;&lt;_»\"><span class=\"name\">«term_&lt;&lt;&lt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L290-L290","name":"«term_%_»","line":290,"kind":"def","docLink":"./Init/Notation.html#«term_%_»","doc":"`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_%_»\"><span class=\"name\">«term_%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L289-L289","name":"«term_/_»","line":289,"kind":"def","docLink":"./Init/Notation.html#«term_/_»","doc":"`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b < natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_/_»\"><span class=\"name\">«term_/_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L288-L288","name":"«term_*_»","line":288,"kind":"def","docLink":"./Init/Notation.html#«term_*_»","doc":"`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_*_»\"><span class=\"name\">«term_*_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L287-L287","name":"«term_-_»","line":287,"kind":"def","docLink":"./Init/Notation.html#«term_-_»","doc":"`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_-_»\"><span class=\"name\">«term_-_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L286-L286","name":"«term_+_»","line":286,"kind":"def","docLink":"./Init/Notation.html#«term_+_»","doc":"`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_+_»\"><span class=\"name\">«term_+_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L285-L285","name":"«term_&&&_»","line":285,"kind":"def","docLink":"./Init/Notation.html#«term_&&&_»","doc":"`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&&` in identifiers is `and`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_&amp;&amp;&amp;_»\"><span class=\"name\">«term_&amp;&amp;&amp;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L284-L284","name":"«term_^^^_»","line":284,"kind":"def","docLink":"./Init/Notation.html#«term_^^^_»","doc":"`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^^^` in identifiers is `xor`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_^^^_»\"><span class=\"name\">«term_^^^_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L283-L283","name":"«term_|||_»","line":283,"kind":"def","docLink":"./Init/Notation.html#«term_|||_»","doc":"`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `|||` in identifiers is `or`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_|||_»\"><span class=\"name\">«term_|||_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L282-L282","name":"«term_∣_»","line":282,"kind":"def","docLink":"./Init/Notation.html#«term_∣_»","doc":"Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∣_»\"><span class=\"name\">«term_∣_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L276-L276","name":"«term_×'_»","line":276,"kind":"def","docLink":"./Init/Notation.html#«term_×'_»","doc":"A product type in which the types may be propositions, usually written `α ×' β`.\n\nThis type is primarily used internally and as an implementation detail of proof automation. It is\nrarely useful in hand-written code.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×'` in identifiers is `PProd`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_×'_»\"><span class=\"name\">«term_×'_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L275-L275","name":"«term_×_»","line":275,"kind":"def","docLink":"./Init/Notation.html#«term_×_»","doc":"The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_×_»\"><span class=\"name\">«term_×_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L274-L274","name":"«term_∘_»","line":274,"kind":"def","docLink":"./Init/Notation.html#«term_∘_»","doc":"Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«term_∘_»\"><span class=\"name\">«term_∘_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L262-L272","name":"rawNatLit","line":262,"kind":"def","docLink":"./Init/Notation.html#rawNatLit","doc":"The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#rawNatLit\"><span class=\"name\">rawNatLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L260-L260","name":"stx!_","line":260,"kind":"def","docLink":"./Init/Notation.html#stx!_","doc":"`!p` parses the negation of `p`. That is, it fails if `p` succeeds, and\notherwise parses nothing. It has arity 0.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#stx!_\"><span class=\"name\">stx!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L254-L254","name":"«stx_,+,?»","line":254,"kind":"def","docLink":"./Init/Notation.html#«stx_,+,?»","doc":"`p,+,?` is shorthand for `sepBy1(p, \",\", allowTrailingSep)`.\nIt parses 1 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_,+,?»\"><span class=\"name\">«stx_,+,?»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L244-L244","name":"«stx_,*,?»","line":244,"kind":"def","docLink":"./Init/Notation.html#«stx_,*,?»","doc":"`p,*,?` is shorthand for `sepBy(p, \",\", allowTrailingSep)`.\nIt parses 0 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `empty | p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_,*,?»\"><span class=\"name\">«stx_,*,?»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L234-L234","name":"«stx_,+»","line":234,"kind":"def","docLink":"./Init/Notation.html#«stx_,+»","doc":"`p,+` is shorthand for `sepBy(p, \",\")`. It parses 1 or more occurrences of\n`p` separated by `,`, that is: `p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_,+»\"><span class=\"name\">«stx_,+»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L226-L226","name":"«stx_,*»","line":226,"kind":"def","docLink":"./Init/Notation.html#«stx_,*»","doc":"`p,*` is shorthand for `sepBy(p, \",\")`. It parses 0 or more occurrences of\n`p` separated by `,`, that is: `empty | p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_,*»\"><span class=\"name\">«stx_,*»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L196-L211","name":"«stx_<|>_»","line":196,"kind":"def","docLink":"./Init/Notation.html#«stx_<|>_»","doc":"`p1 <|> p2` is shorthand for `orelse(p1, p2)`, and parses either `p1` or `p2`.\nIt does not backtrack, meaning that if `p1` consumes at least one token then\n`p2` will not be tried. Therefore, the parsers should all differ in their first\ntoken. The `atomic(p)` parser combinator can be used to locally backtrack a parser.\n(For full backtracking, consider using extensible syntax classes instead.)\n\nOn success, if the inner parser does not generate exactly one node, it will be\nautomatically wrapped in a `group` node, so the result will always be arity 1.\n\nThe `<|>` combinator does not generate a node of its own, and in particular\ndoes not tag the inner parsers to distinguish them, which can present a problem\nwhen reconstructing the parse. A well formed `<|>` parser should use disjoint\nnode kinds for `p1` and `p2`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_&lt;|&gt;_»\"><span class=\"name\">«stx_&lt;|&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L183-L194","name":"stx_?","line":183,"kind":"def","docLink":"./Init/Notation.html#stx_?","doc":"`(p)?` is shorthand for `optional(p)`. It uses parser `p` 0 or 1 times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\n`p` is allowed to have arity n > 1 (in which case the node will have either 0 or n children),\nbut if it has arity 0 then the result will be ambiguous.\n\nBecause `?` is an identifier character, `ident?` will not work as intended.\nYou have to write either `ident ?` or `(ident)?` for it to parse as the `?` combinator\napplied to the `ident` parser.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#stx_?\"><span class=\"name\">stx_?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L175-L181","name":"«stx_*»","line":175,"kind":"def","docLink":"./Init/Notation.html#«stx_*»","doc":"`p*` is shorthand for `many(p)`. It uses parser `p` 0 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_*»\"><span class=\"name\">«stx_*»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L167-L173","name":"«stx_+»","line":167,"kind":"def","docLink":"./Init/Notation.html#«stx_+»","doc":"`p+` is shorthand for `many1(p)`. It uses parser `p` 1 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«stx_+»\"><span class=\"name\">«stx_+»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L147-L147","name":"«prio(_)»","line":147,"kind":"def","docLink":"./Init/Notation.html#«prio(_)»","doc":"Parentheses are used for grouping priority expressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«prio(_)»\"><span class=\"name\">«prio(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L145-L145","name":"prioHigh","line":145,"kind":"def","docLink":"./Init/Notation.html#prioHigh","doc":"The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#prioHigh\"><span class=\"name\">prioHigh</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L143-L143","name":"prioMid","line":143,"kind":"def","docLink":"./Init/Notation.html#prioMid","doc":"The standardized \"medium\" priority `mid = 500`. This is lower than `default`, and higher than `low`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#prioMid\"><span class=\"name\">prioMid</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L139-L139","name":"prioLow","line":139,"kind":"def","docLink":"./Init/Notation.html#prioLow","doc":"The standardized \"low\" priority `low = 100`, for things that should be lower than default priority. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#prioLow\"><span class=\"name\">prioLow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L137-L137","name":"prioDefault","line":137,"kind":"def","docLink":"./Init/Notation.html#prioDefault","doc":"The default priority `default = 1000`, which is used when no priority is set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#prioDefault\"><span class=\"name\">prioDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L134-L134","name":"termMax_prec","line":134,"kind":"def","docLink":"./Init/Notation.html#termMax_prec","doc":"`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#termMax_prec\"><span class=\"name\">termMax_prec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L129-L129","name":"precMin1","line":129,"kind":"def","docLink":"./Init/Notation.html#precMin1","doc":"`(min+1)` (we can only write `min+1` after `Meta.lean`) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#precMin1\"><span class=\"name\">precMin1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L127-L127","name":"precMin","line":127,"kind":"def","docLink":"./Init/Notation.html#precMin","doc":"Minimum precedence used in term parsers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#precMin\"><span class=\"name\">precMin</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L125-L125","name":"«prec(_)»","line":125,"kind":"def","docLink":"./Init/Notation.html#«prec(_)»","doc":"Parentheses are used for grouping precedence expressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#«prec(_)»\"><span class=\"name\">«prec(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L123-L123","name":"precLead","line":123,"kind":"def","docLink":"./Init/Notation.html#precLead","doc":"Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#precLead\"><span class=\"name\">precLead</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L121-L121","name":"precArg","line":121,"kind":"def","docLink":"./Init/Notation.html#precArg","doc":"Precedence used for application arguments (`do`, `by`, ...). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#precArg\"><span class=\"name\">precArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L119-L119","name":"precMax","line":119,"kind":"def","docLink":"./Init/Notation.html#precMax","doc":"Maximum precedence used in term parsers, in particular for terms in\nfunction position (`ident`, `paren`, ...)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#precMax\"><span class=\"name\">precMax</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L110-L111","name":"Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","line":110,"kind":"instance","docLink":"./Init/Notation.html#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds\"><span class=\"name\">Lean</span>.<span class=\"name\">instCoeSyntaxNodeKindSyntaxNodeKinds</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Init/Prelude.html#Lean.SyntaxNodeKind\">SyntaxNodeKind</a> <a href=\"./Init/Prelude.html#Lean.SyntaxNodeKinds\">SyntaxNodeKinds</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L107-L108","name":"Lean.instCoeOutTSyntaxSyntax","line":107,"kind":"instance","docLink":"./Init/Notation.html#Lean.instCoeOutTSyntaxSyntax","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.instCoeOutTSyntaxSyntax\"><span class=\"name\">Lean</span>.<span class=\"name\">instCoeOutTSyntaxSyntax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ks</span> : <a href=\"./Init/Prelude.html#Lean.SyntaxNodeKinds\">SyntaxNodeKinds</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeOut\">CoeOut</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">ks</span>)</span> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L102-L103","name":"Lean.Parser.Syntax.subPrio","line":102,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Syntax.subPrio","doc":"Subtraction of priorities. This is normally used only for offsetting, e.g. `default - 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Syntax.subPrio\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Syntax</span>.<span class=\"name\">subPrio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L100-L101","name":"Lean.Parser.Syntax.addPrio","line":100,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Syntax.addPrio","doc":"Addition of priorities. This is normally used only for offsetting, e.g. `default + 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Syntax.addPrio\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Syntax</span>.<span class=\"name\">addPrio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L97-L98","name":"Lean.Parser.Syntax.subPrec","line":97,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Syntax.subPrec","doc":"Subtraction of precedences. This is normally used only for offsetting, e.g. `max - 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Syntax.subPrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Syntax</span>.<span class=\"name\">subPrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L95-L96","name":"Lean.Parser.Syntax.addPrec","line":95,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Syntax.addPrec","doc":"Addition of precedences. This is normally used only for offsetting, e.g. `max + 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Syntax.addPrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Syntax</span>.<span class=\"name\">addPrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L78-L87","name":"Lean.Parser.Category.prec","line":78,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.prec","doc":"`prec` is a builtin syntax category for precedences. A precedence is a value\nthat expresses how tightly a piece of syntax binds: for example `1 + 2 * 3` is\nparsed as `1 + (2 * 3)` because `*` has a higher precedence than `+`.\nHigher numbers denote higher precedence.\nIn addition to literals like `37`, there are some special named precedence levels:\n* `arg` for the precedence of function arguments\n* `max` for the highest precedence used in term parsers (not actually the maximum possible value)\n* `lead` for the precedence of terms not supposed to be used as arguments\nand you can also add and subtract precedences. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.prec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">prec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L70-L76","name":"Lean.Parser.Category.prio","line":70,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.prio","doc":"`prio` is a builtin syntax category for priorities.\nPriorities are used in many different attributes.\nHigher numbers denote higher priority, and for example typeclass search will\ntry high priority instances before low priority.\nIn addition to literals like `37`, you can also use `low`, `mid`, `high`, as well as\nadd and subtract priorities. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.prio\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">prio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L66-L68","name":"Lean.Parser.Category.stx","line":66,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.stx","doc":"`stx` is a builtin syntax category for syntax. This is the abbreviated\nparser notation used inside `syntax` and `macro` declarations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.stx\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">stx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L62-L64","name":"Lean.Parser.Category.attr","line":62,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.attr","doc":"`attr` is a builtin syntax category for attributes.\nDeclarations can be annotated with attributes using the `@[...]` notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.attr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">attr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L57-L60","name":"Lean.Parser.Category.level","line":57,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.level","doc":"`level` is a builtin syntax category for universe levels.\nThis is the `u` in `Sort u`: it can contain `max` and `imax`, addition with\nconstants, and variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.level\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">level</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L53-L55","name":"Lean.Parser.Category.structInstFieldDecl","line":53,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.structInstFieldDecl","doc":"`structInstFieldDecl` is the syntax category for value declarations for fields in structure instance notation.\nFor example, the `:= 1` and `| 0 => 0 | n + 1 => n` in `{ x := 1, f | 0 => 0 | n + 1 => n }` are in the `structInstFieldDecl` class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.structInstFieldDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">structInstFieldDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L49-L51","name":"Lean.Parser.Category.doElem","line":49,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.doElem","doc":"`doElem` is a builtin syntax category for elements that can appear in the `do` notation.\nFor example, `let x ← e` is a `doElem`, and a `do` block consists of a list of `doElem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.doElem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">doElem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L39-L47","name":"Lean.Parser.Category.tactic","line":39,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.tactic","doc":"`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.tactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">tactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L32-L37","name":"Lean.Parser.Category.term","line":32,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.term","doc":"`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.term\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L25-L30","name":"Lean.Parser.Category.command","line":25,"kind":"def","docLink":"./Init/Notation.html#Lean.Parser.Category.command","doc":"`command` is the syntax category for things that appear at the top level\nof a lean file. For example, `def foo := 1` is a `command`, as is\n`namespace Foo` and `end Foo`. Commands generally have an effect on the state of\nadding something to the environment (like a new definition), as well as\ncommands like `variable` which modify future commands within a scope. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.command\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">command</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L21-L21","name":"Lean.Parser.Category.mk","line":21,"kind":"ctor","docLink":"./Init/Notation.html#Lean.Parser.Category.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Notation.lean#L17-L21","name":"Lean.Parser.Category","line":17,"kind":"structure","docLink":"./Init/Notation.html#Lean.Parser.Category","doc":"Auxiliary type used to represent syntax categories. We mainly use auxiliary\ndefinitions with this type to attach doc strings to syntax categories.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Notation.html#Lean.Parser.Category\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}