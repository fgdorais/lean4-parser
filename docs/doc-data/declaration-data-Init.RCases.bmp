{"name":"Init.RCases","instances":[],"imports":["Init.Tactics","Init.Meta"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L183-L193","name":"Lean.Parser.Tactic.rintro","line":183,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintro","doc":"The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L154-L171","name":"Lean.Parser.Tactic.obtain","line":154,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.obtain","doc":"The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.obtain\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">obtain</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L109-L152","name":"Lean.Parser.Tactic.rcases","line":109,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcases","doc":"`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L93-L97","name":"Lean.Parser.Tactic.rintroPat.binder","line":93,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.binder","doc":"A multi argument binder `(pat1 pat2 : ty)` binds a list of patterns and gives them all type `ty`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.binder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">binder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L91-L92","name":"Lean.Parser.Tactic.rintroPat.one","line":91,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.one","doc":"An `rcases` pattern is an `rintro` pattern "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L89-L90","name":"Lean.Parser.Category.rintroPat","line":89,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Category.rintroPat","doc":"The syntax category of `rintro` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Category.rintroPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rintroPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L89-L90","name":"Lean.Parser.Tactic.rintroPat.quot","line":89,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L86-L87","name":"Lean.Parser.Tactic.rcasesPat.paren","line":86,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.paren","doc":"`(pat)` is a pattern which resets the precedence to low "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L81-L85","name":"Lean.Parser.Tactic.rcasesPat.tuple","line":81,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.tuple","doc":"`⟨pat, ...⟩` is a pattern which matches on a tuple-like constructor\nor multi-argument inductive constructor\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L76-L80","name":"Lean.Parser.Tactic.rcasesPat.explicit","line":76,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.explicit","doc":"A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\nwhile leaving the `@` off will only use the patterns on the explicit arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L74-L75","name":"Lean.Parser.Tactic.rcasesPat.clear","line":74,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear","doc":"`-` is a pattern which removes the value from the context "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L72-L73","name":"Lean.Parser.Tactic.rcasesPat.ignore","line":72,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore","doc":"`_` is a pattern which ignores the value and gives it an inaccessible name "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">ignore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L70-L71","name":"Lean.Parser.Tactic.rcasesPat.one","line":70,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one","doc":"`x` is a pattern which binds `x` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L68-L69","name":"Lean.Parser.Tactic.rcasesPatLo","line":68,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatLo","doc":"A low precedence `rcases` pattern is a `rcasesPatMed` optionally followed by `: ty` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatLo\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPatLo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L66-L67","name":"Lean.Parser.Tactic.rcasesPatMed","line":66,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed","doc":"A medium precedence `rcases` pattern is a list of `rcasesPat` separated by `|` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPatMed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L64-L65","name":"Lean.Parser.Tactic.rcasesPat.quot","line":64,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/RCases.lean#L64-L65","name":"Lean.Parser.Category.rcasesPat","line":64,"kind":"def","docLink":"./Init/RCases.html#Lean.Parser.Category.rcasesPat","doc":"The syntax category of `rcases` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Category.rcasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rcasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"}]}