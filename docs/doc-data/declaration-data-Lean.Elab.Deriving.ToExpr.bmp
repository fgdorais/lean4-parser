{"name":"Lean.Elab.Deriving.ToExpr","instances":[],"imports":["Lean.Meta.Transform","Lean.Elab.Deriving.Basic","Lean.Elab.Deriving.Util","Lean.ToLevel","Lean.ToExpr"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L220-L231","name":"Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler","line":220,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler","doc":"The main entry point to the `ToExpr` deriving handler.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceHandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Command.CommandElabM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L211-L218","name":"Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds","line":211,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds","doc":"Returns all the commands necessary to construct the `ToExpr` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L186-L209","name":"Lean.Elab.Deriving.ToExpr.mkInstanceCmds","line":186,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkInstanceCmds","doc":"Assuming all of the auxiliary definitions exist,\ncreates all the `instance` commands for the `ToExpr` instances for the (mutual) inductive type(s).\nThis is a modified copy of `Lean.Elab.Deriving.mkInstanceCmds` to account for `ToLevel` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkInstanceCmds\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Command\">Command</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L175-L183","name":"Lean.Elab.Deriving.ToExpr.mkAuxFunctions","line":175,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunctions","doc":"Creates all the auxiliary functions (using `mkAuxFunction`) for the (mutual) inductive type(s).\nWraps the resulting definition commands in `mutual ... end`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunctions\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAuxFunctions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L140-L173","name":"Lean.Elab.Deriving.ToExpr.mkAuxFunction","line":140,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunction","doc":"Makes a `toExpr` function for the given inductive type.\nThe implementation of each `toExpr` function for a (mutual) inductive type is given as top-level private definitions.\nThese are assembled into `ToExpr` instances in `mkInstanceCmds`.\nFor mutual/nested inductive types, then each of the types' `ToExpr` instances are provided as local instances,\nto wire together the recursion (necessitating these auxiliary definitions being `partial`).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunction\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAuxFunction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Command\">Command</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L110-L137","name":"Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls","line":110,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls","doc":"For nested and mutually recursive inductive types, we define `partial` instances,\nand the strategy is to have local `ToExpr` instances in scope for the body of each instance.\nThis way, each instance can freely use `toExpr` and `toTypeExpr` for each of the types in `ctx`.\n\nThis is a modified copy of `Lean.Elab.Deriving.mkLocalInstanceLetDecls`,\nsince we need to include the `toTypeExpr` field in the `letDecl`\nNote that, for simplicity, each instance gets its own definition of each others' `toTypeExpr` fields.\nThese are very simple fields, so avoiding the duplication is not worth it.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkLocalInstanceLetDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelInsts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.letDecl</span>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L76-L108","name":"Lean.Elab.Deriving.ToExpr.mkToExprBody.mkAlts","line":76,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody.mkAlts","doc":"Create the `match` cases, one per constructor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody.mkAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprBody</span>.<span class=\"name\">mkAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">header</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Header</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">auxFunName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelInsts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L63-L108","name":"Lean.Elab.Deriving.ToExpr.mkToExprBody","line":63,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody","doc":"Creates the body of the `toExpr` function for the `ToExpr` instance, which is a `match` expression\nthat calls `toExpr` and `toTypeExpr` to assemble an expression for a given term.\nFor recursive inductive types, `auxFunName` refers to the `ToExpr` instance for the current type.\nFor mutually recursive types, we rely on the local instances set up by `mkLocalInstanceLetDecls`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprBody</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">header</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Header</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">auxFunName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelInsts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L47-L61","name":"Lean.Elab.Deriving.ToExpr.mkToTypeExpr","line":47,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToTypeExpr","doc":"Creates a term that evaluates to an expression representing the inductive type.\nUses `toExpr` and `toTypeExpr` for the arguments to the type constructor.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToTypeExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToTypeExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L40-L45","name":"Lean.Elab.Deriving.ToExpr.updateIndType","line":40,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.updateIndType","doc":"Fixes the output of `mkInductiveApp` to explicitly reference universe levels. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.updateIndType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">updateIndType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Elab/Deriving/ToExpr.lean#L34-L38","name":"Lean.Elab.Deriving.ToExpr.mkAppNTerm","line":34,"kind":"def","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAppNTerm","doc":"Given `args := #[e₁, e₂, …, eₙ]`, constructs the syntax `Expr.app (… (Expr.app (Expr.app f e₁) e₂) …) eₙ`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAppNTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAppNTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a></span></div></div>"}]}