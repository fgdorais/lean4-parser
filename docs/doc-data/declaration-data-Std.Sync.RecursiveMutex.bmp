{"name":"Std.Sync.RecursiveMutex","instances":[{"typeNames":["Std.BaseRecursiveMutex"],"name":"Std.instNonemptyBaseRecursiveMutex","className":"Nonempty"},{"typeNames":["Std.RecursiveMutex"],"name":"Std.instNonemptyRecursiveMutex","className":"Nonempty"},{"typeNames":["Std.RecursiveMutex","Std.BaseRecursiveMutex"],"name":"Std.instCoeOutRecursiveMutexBaseRecursiveMutex","className":"CoeOut"}],"imports":["Std.Sync.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L85-L100","name":"Std.RecursiveMutex.tryAtomically","line":85,"kind":"def","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.tryAtomically","doc":"`mutex.tryAtomically k` tries to lock `mutex` and runs `k` on it if it succeeds. On success the\nreturn value of `k` is returned as `some`, on failure `none` is returned.\n\nThis function does not block on the `mutex`. Additionally `mutex.tryAtomically`, while already\nholding the underlying `BaseRecursiveMutex` in the same thread, does not block.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.tryAtomically\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">tryAtomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">β</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L71-L83","name":"Std.RecursiveMutex.atomically","line":71,"kind":"def","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.atomically","doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex.\n\nCalling `mutex.atomically` while already holding the underlying `BaseRecursiveMutex` in the same\nthread does not block.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.atomically\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">atomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L67-L69","name":"Std.RecursiveMutex.new","line":67,"kind":"def","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.new","doc":"Creates a new recursive mutex. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">new</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L65-L65","name":"Std.instCoeOutRecursiveMutexBaseRecursiveMutex","line":65,"kind":"instance","docLink":"./Std/Sync/RecursiveMutex.html#Std.instCoeOutRecursiveMutexBaseRecursiveMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instCoeOutRecursiveMutexBaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instCoeOutRecursiveMutexBaseRecursiveMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeOut\">CoeOut</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span>)</span> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L63-L63","name":"Std.instNonemptyRecursiveMutex","line":63,"kind":"instance","docLink":"./Std/Sync/RecursiveMutex.html#Std.instNonemptyRecursiveMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instNonemptyRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyRecursiveMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α✝</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α✝</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α✝</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L62-L62","name":"Std.RecursiveMutex.mutex","line":62,"kind":"def","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.mutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.mutex\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">mutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L53-L63","name":"Std.RecursiveMutex","line":53,"kind":"structure","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex","doc":"Recursive (or reentrant) mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `RecursiveMutex α` is similar to `IO.Ref α`, except that concurrent accesses are guarded\nby a mutex instead of atomic pointer operations and busy-waiting. Additionally locking a\n`RecursiveMutex` multiple times from the same thread does not block, unlike `Mutex`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L43-L51","name":"Std.BaseRecursiveMutex.unlock","line":43,"kind":"opaque","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.unlock","doc":"Unlocks a `BaseRecursiveMutex`. The owning thread must make as many `unlock` calls as `lock` and\n`tryLock` calls in order to fully relinquish ownership of the mutex.\n\nThe current thread must have already locked the mutex at least once.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.unlock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">unlock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L33-L41","name":"Std.BaseRecursiveMutex.tryLock","line":33,"kind":"opaque","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.tryLock","doc":"Attempts to lock a `BaseRecursiveMutex`. If the mutex is not available return `false`, otherwise\nlock it and return `true`.\n\nThis function does not block. Furthermore the same thread may acquire the lock multiple times\nthrough this function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.tryLock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">tryLock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L26-L31","name":"Std.BaseRecursiveMutex.lock","line":26,"kind":"opaque","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.lock","doc":"Locks a `BaseRecursiveMutex`. Waits until no other thread has locked the mutex.\nIf the current thread already holds the mutex this function doesn't block.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.lock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">lock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L22-L24","name":"Std.BaseRecursiveMutex.new","line":22,"kind":"opaque","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.new","doc":"Creates a new `BaseRecursiveMutex`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L20-L20","name":"Std.instNonemptyBaseRecursiveMutex","line":20,"kind":"instance","docLink":"./Std/Sync/RecursiveMutex.html#Std.instNonemptyBaseRecursiveMutex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instNonemptyBaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyBaseRecursiveMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Std/Sync/RecursiveMutex.lean#L13-L18","name":"Std.BaseRecursiveMutex","line":13,"kind":"def","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex","doc":"Recursive (or reentrant) exclusion primitive.\n\nIf you want to guard shared state, use `RecursiveMutex α` instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}