{"name":"Lean.Parser.Extra","instances":[],"imports":["Lean.Parser.Extension","Lean.PrettyPrinter.Parenthesizer","Lean.PrettyPrinter.Formatter"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L297-L297","name":"Lean.Parser.«termRegister_parser_alias(Kind:=_)______»","line":297,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.«termRegister_parser_alias(Kind:=_)______»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.«termRegister_parser_alias(Kind:=_)______»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">«termRegister_parser_alias(Kind:=_)______»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L282-L286","name":"Lean.ppHardLineUnlessUngrouped.formatter","line":282,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L277-L281","name":"Lean.ppDedentIfGrouped.formatter","line":277,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedentIfGrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L275-L276","name":"Lean.ppAllowUngrouped.formatter","line":275,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppAllowUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L271-L273","name":"Lean.ppDedent.formatter","line":271,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppDedent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L270-L270","name":"Lean.ppIndent.formatter","line":270,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppIndent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L269-L269","name":"Lean.ppRealGroup.formatter","line":269,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealGroup</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L268-L268","name":"Lean.ppRealFill.formatter","line":268,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealFill</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L267-L267","name":"Lean.ppLine.formatter","line":267,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppLine.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppLine.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppLine</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L266-L266","name":"Lean.ppSpace.formatter","line":266,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppSpace.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L265-L265","name":"Lean.ppHardSpace.formatter","line":265,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L254-L258","name":"Lean.Parser.ppHardLineUnlessUngrouped","line":254,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped","doc":"No-op parser combinator that prints a line break.\nThe line break is soft if the combinator is followed\nby an ungrouped parser (see ppAllowUngrouped), otherwise hard. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L248-L252","name":"Lean.Parser.ppDedentIfGrouped","line":248,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped","doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax,\nif it was grouped by the category parser.\nDedenting can in particular be used to counteract automatic indentation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedentIfGrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L236-L246","name":"Lean.Parser.ppAllowUngrouped","line":236,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped","doc":"No-op parser combinator that allows the pretty printer to omit the group and\nindent operation in the enclosing category parser.\n```\nsyntax ppAllowUngrouped \"by \" tacticSeq : term\n-- allows a `by` after `:=` without linebreak in between:\ntheorem foo : True := by\n  trivial\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppAllowUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L231-L234","name":"Lean.Parser.ppDedent","line":231,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedent","doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax.\nDedenting can in particular be used to counteract automatic indentation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L227-L230","name":"Lean.Parser.ppGroup","line":227,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppGroup","doc":"No-op parser combinator that advises the pretty printer to group and indent the given syntax.\nBy default, only syntax categories are grouped. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L225-L226","name":"Lean.Parser.ppIndent","line":225,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppIndent","doc":"No-op parser combinator that advises the pretty printer to indent the given syntax without grouping it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppIndent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L223-L224","name":"Lean.Parser.ppRealGroup","line":223,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup","doc":"No-op parser combinator that advises the pretty printer to emit a `Format.group` node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealGroup</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L221-L222","name":"Lean.Parser.ppRealFill","line":221,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill","doc":"No-op parser combinator that advises the pretty printer to emit a `Format.fill` node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealFill</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L219-L220","name":"Lean.Parser.ppLine","line":219,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppLine","doc":"No-op parser that advises the pretty printer to emit a hard line break. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppLine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppLine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L217-L218","name":"Lean.Parser.ppSpace","line":217,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppSpace","doc":"No-op parser that advises the pretty printer to emit a space/soft line break. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L215-L216","name":"Lean.Parser.ppHardSpace","line":215,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace","doc":"No-op parser that advises the pretty printer to emit a non-breaking space. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L211-L213","name":"Lean.Parser.patternIgnore","line":211,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore","doc":"No-op parser combinator that annotates subtrees to be ignored in syntax patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">patternIgnore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L208-L209","name":"Lean.Parser.notSymbol","line":208,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.notSymbol","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.notSymbol\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">notSymbol</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L204-L204","name":"Lean.Parser.sepBy1Indent.formatter","line":204,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pSep</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L189-L202","name":"Lean.Parser.sepByIndent.formatter","line":189,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pSep</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L184-L186","name":"Lean.Parser.sepBy1Indent","line":184,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">psep</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">symbol</a> <span class=\"fn\">sep</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowTrailingSep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L180-L182","name":"Lean.Parser.sepByIndent","line":180,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">psep</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">symbol</a> <span class=\"fn\">sep</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowTrailingSep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L171-L178","name":"Lean.Parser.manyIndent","line":171,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.manyIndent","doc":"The parser `manyIndent(p)` is equivalent to `withPosition((colGe p)*)`. This has the effect of\nparsing zero or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.manyIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">manyIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L162-L169","name":"Lean.Parser.many1Indent","line":162,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1Indent","doc":"The parser `many1Indent(p)` is equivalent to `withPosition((colGe p)+)`. This has the effect of\nparsing one or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L153-L160","name":"Lean.Parser.group","line":153,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.group","doc":"The parser `group(p)` parses the same thing as `p`, but it wraps the results in a `groupKind`\nnode.\n\nThis parser always has arity 1, even if `p` does not. Parsers like `p*` are automatically\nrewritten to `group(p)*` if `p` does not have arity 1, so that the results from separate invocations\nof `p` can be differentiated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.group\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">group</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L144-L151","name":"Lean.Parser.nameLit","line":144,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.nameLit","doc":"The parser `name` parses a name literal like `` `foo``. The syntax is the same as for identifiers\n(see `ident`) but with a leading backquote.\n\nThis parser has arity 1: it produces a `nameLitKind` node containing the raw literal\n(including the backquote).\nYou can use `TSyntax.getName` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.nameLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">nameLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L133-L142","name":"Lean.Parser.charLit","line":133,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.charLit","doc":"The parser `char` parses a character literal, such as `'a'` or `'\\n'`. Character literals can\ncontain C-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters\nlike `∈`, but must evaluate to a single unicode codepoint, so `'♥'` is allowed but `'❤️'` is not\n(since it is two codepoints but one grapheme cluster).\n\nThis parser has arity 1: it produces a `charLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getChar` to decode the string from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.charLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">charLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L123-L131","name":"Lean.Parser.strLit","line":123,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.strLit","doc":"The parser `str` parses a string literal, such as `\"foo\"` or `\"\\r\\n\"`. Strings can contain\nC-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters like `∈`.\nNewlines in a string are interpreted literally.\n\nThis parser has arity 1: it produces a `strLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getString` to decode the string from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.strLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">strLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L115-L121","name":"Lean.Parser.scientificLit","line":115,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.scientificLit","doc":"The parser `scientific` parses a scientific-notation literal, such as `1.3e-24`.\n\nThis parser has arity 1: it produces a `scientificLitKind` node containing an atom with the text\nof the literal.\nYou can use `TSyntax.getScientific` to extract the parts from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.scientificLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">scientificLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L102-L113","name":"Lean.Parser.numLit","line":102,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.numLit","doc":"The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.numLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">numLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L87-L100","name":"Lean.Parser.hygieneInfo","line":87,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo","doc":"The parser `hygieneInfo` parses no text, but captures the current macro scope information\nas though it parsed an identifier at the current position. It returns a `hygieneInfoKind` node\naround an `.ident` which is `Name.anonymous` but with macro scopes like a regular identifier.\n\nThis is used to implement `have := ...` syntax: the `hygieneInfo` between the `have` and `:=`\nsubstitutes for the identifier which would normally go there as in `have x :=`, so that we\ncan expand `have :=` to `have this :=` while retaining the usual macro name resolution behavior.\nSee [doc/macro_overview.md](https://github.com/leanprover/lean4/blob/master/doc/macro_overview.md)\nfor more information about macro hygiene.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getHygieneInfo` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">hygieneInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L84-L85","name":"Lean.Parser.rawIdent","line":84,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.rawIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.rawIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">rawIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L80-L81","name":"Lean.Parser.identWithPartialTrailingDot","line":80,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.identWithPartialTrailingDot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.identWithPartialTrailingDot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">identWithPartialTrailingDot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L62-L74","name":"Lean.Parser.ident","line":62,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ident","doc":"The parser `ident` parses a single identifier, possibly with namespaces, such as `foo` or\n`bar.baz`. The identifier must not be a declared token, so for example it will not match `\"def\"`\nbecause `def` is a keyword token. Tokens are implicitly declared by using them in string literals\nin parser declarations, so `syntax foo := \"bla\"` will make `bla` no longer legal as an identifier.\n\nIdentifiers can contain special characters or keywords if they are escaped using the `«»` characters:\n`«def»` is an identifier named `def`, and `«x»` is treated the same as `x`. This is useful for\nusing disallowed characters in identifiers such as `«foo.bar».baz` or `«hello world»`.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getId` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L47-L60","name":"Lean.Parser.many1","line":47,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1","doc":"The parser `many1(p)`, or `p+`, repeats `p` until it fails, and returns the list of results.\n`p` must succeed at least once, or this parser will fail.\n\nNote that this parser produces the same parse tree as the `many(p)` / `p*` combinator,\nand one matches both `p*` and `p+` using `$[ .. ]*` syntax in a syntax match.\n(There is no `$[ .. ]+` syntax.)\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L37-L45","name":"Lean.Parser.many","line":37,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many","doc":"The parser `many(p)`, or `p*`, repeats `p` until it fails, and returns the list of results.\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Parser/Extra.lean#L25-L35","name":"Lean.Parser.optional","line":25,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.optional","doc":"The parser `optional(p)`, or `(p)?`, parses `p` if it succeeds,\notherwise it succeeds with no value.\n\nNote that because `?` is a legal identifier character, one must write `(p)?` or `p ?` for\nit to parse correctly. `ident?` will not work; one must write `(ident)?` instead.\n\nThis parser has arity 1: it produces a `nullKind` node containing either zero arguments\n(for the `none` case) or the list of arguments produced by `p`.\n(In particular, if `p` has arity 0 then the two cases are not differentiated!) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.optional\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">optional</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>"}]}