<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.FunInd</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.FunInd";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Elab/Command.html">Lean.Elab.Command</a></li><li><a href="../../.././Lean/Meta/ArgsPacker.html">Lean.Meta.ArgsPacker</a></li><li><a href="../../.././Lean/Meta/Basic.html">Lean.Meta.Basic</a></li><li><a href="../../.././Lean/Meta/Check.html">Lean.Meta.Check</a></li><li><a href="../../.././Lean/Meta/Injective.html">Lean.Meta.Injective</a></li><li><a href="../../.././Lean/Meta/PProdN.html">Lean.Meta.PProdN</a></li><li><a href="../../.././Lean/Meta/Tactic/ElimInfo.html">Lean.Meta.Tactic.ElimInfo</a></li><li><a href="../../.././Lean/Meta/Tactic/FunIndInfo.html">Lean.Meta.Tactic.FunIndInfo</a></li><li><a href="../../.././Lean/Meta/Tactic/Subst.html">Lean.Meta.Tactic.Subst</a></li><li><a href="../../.././Lean/Elab/PreDefinition/Structural/Eqns.html">Lean.Elab.PreDefinition.Structural.Eqns</a></li><li><a href="../../.././Lean/Elab/PreDefinition/Structural/FindRecArg.html">Lean.Elab.PreDefinition.Structural.FindRecArg</a></li><li><a href="../../.././Lean/Elab/PreDefinition/Structural/IndGroupInfo.html">Lean.Elab.PreDefinition.Structural.IndGroupInfo</a></li><li><a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html">Lean.Elab.PreDefinition.WF.Eqns</a></li><li><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html">Lean.Meta.Match.MatcherApp.Transform</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.FunInd" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.lambdaTelescope1"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">lambdaTelescope1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.run"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.eval"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.exec"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">exec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.tell"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">tell</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.localM"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">localM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.localMapM"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">localMapM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.ask"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">ask</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M.branch"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">branch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.foldAndCollect"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">foldAndCollect</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deduplicateIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deduplicateIHs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.assertIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">assertIHs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanupAfter"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanupAfter.go"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanupAfter.allHeqToEq"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">allHeqToEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">cleanupAfter?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M2"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M2.run"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M2.branch"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span>.<span class="name">branch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.buildInductionCase"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionCase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.mkLambdaFVarsMasked"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkLambdaFVarsMasked</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.maskArray"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">maskArray</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.withRewrittenMotive"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withRewrittenMotive</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.inLastArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">inLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.withRewrittenMotiveArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withRewrittenMotiveArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.inProdLambdaLastArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">inProdLambdaLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.rwIfWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwIfWith</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.rwLetWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwLetWith</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.rwHaveWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwHaveWith</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.rwFun"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.rwMatcher"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwMatcher</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.buildInductionBody"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.abstractIndependentMVars"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">abstractIndependentMVars</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveUnaryInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveUnaryInduction.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span>.<span class="name">doRealize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.projectMutualInduct"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">projectMutualInduct</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.setNaryFunIndInfo"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">setNaryFunIndInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanPackedArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanPackedArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.unpackMutualInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.unpackMutualInduction.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span>.<span class="name">doRealize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.withLetDecls"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withLetDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.withLetDecls.go"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withLetDecls</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveInductionStructural"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInductionStructural</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveInductionStructural.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInductionStructural</span>.<span class="name">doRealize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveCases"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.isFunInductName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunInductName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.isFunCasesName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunCasesName</span></a></div></nav><main>
<div class="mod_doc"><p>This module contains code to derive, from the definition of a recursive function (structural or
well-founded, possibly mutual), a <strong>functional induction principle</strong> tailored to proofs about that
function(s).</p><p>For example from:</p><pre><code>def ackermann : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a>
  | 0, m =&gt; m + 1
  | n+1, 0 =&gt; ackermann n 1
  | n+1, m+1 =&gt; ackermann n (ackermann (n + 1) m)
</code></pre><p>we get</p><pre><code>ackermann.induct (motive : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → Prop) (case1 : ∀ (m : Nat), motive 0 m)
  (case2 : ∀ (n : Nat), motive n 1 → motive (Nat.succ n) 0)
  (case3 : ∀ (n m : Nat), motive (n + 1) m → motive n (ackermann (n + 1) m) → motive (Nat.succ n) (Nat.succ m))
  (x x : Nat) : motive x x
</code></pre><h2 class="markdown-heading" id="Specification">Specification <a class="hover-link" href="#Specification">#</a></h2><p>The functional induction principle takes the same fixed parameters as the function, and
the motive takes the same non-fixed parameters as the original function.</p><p>For each branch of the original function, there is a case in the induction principle.
Here &quot;branch&quot; roughly corresponds to tail-call positions: branches of top-level
<code>if</code>-<code>then</code>-<code>else</code> and of <code>match</code> expressions.</p><p>For every recursive call in that branch, an induction hypothesis asserting the
motive for the arguments of the recursive call is provided.
If the recursive call is under binders and it, or its proof of termination,
depend on the bound values, then these become assumptions of the inductive
hypothesis.</p><p>Additionally, the local context of the branch (e.g. the condition of an
if-then-else; a let-binding, a have-binding) is provided as assumptions in the
corresponding induction case, if they are likely to be useful (as determined
by <code>MVarId.cleanup</code>).</p><p>Mutual recursion is supported and results in multiple motives.</p><h2 class="markdown-heading" id="Implementation-overview-well-founded-recursion">Implementation overview (well-founded recursion) <a class="hover-link" href="#Implementation-overview-well-founded-recursion">#</a></h2><p>For a non-mutual, unary function <code>foo</code> (or else for the <code>_unary</code> function), we</p><ol>
<li><p>expect its definition to be of the form</p>
<pre><code>def foo := fun x₁ … xₙ (y : a) =&gt; <a href="../../.././Init/WF.html#WellFounded.fix">WellFounded.fix</a> (fun y' oldIH =&gt; body) y
</code></pre>
<p>where <code>xᵢ…</code> are the fixed parameter prefix and <code>y</code> is the varying parameter of
the function.</p>
</li>
<li><p>From this structure we derive the type of the motive, and start assembling the induction
principle:</p>
<pre><code>def foo.induct := fun x₁ … xₙ (motive : (y : a) → Prop) =&gt;
 fix (fun y' newIH =&gt; T[body])
</code></pre>
</li>
<li><p>The first phase, transformation <code>T1[body]</code> (implemented in <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code>)
mirrors the branching structure of <code>foo</code>, i.e. replicates <code><a href="../../.././Init/Prelude.html#dite">dite</a></code> and some matcher applications,
while adjusting their motive. It also unfolds calls to <code>oldIH</code> and collects induction hypotheses
in conditions (see below).</p>
<p>In particular, when translating a <code>match</code> it is prepared to recognize the idiom
as introduced by <code>mkFix</code> via <code><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?">Lean.Meta.MatcherApp.addArg?</a></code>, which refines the type of <code>oldIH</code>
throughout the match. The transformation will replace <code>oldIH</code> with <code>newIH</code> here.</p>
<pre><code>     T[(match (motive := fun oldIH =&gt; …) y with | … =&gt; fun oldIH' =&gt; body) oldIH]
 ==&gt; (match (motive := fun newIH =&gt; …) y with | … =&gt; fun newIH' =&gt; T[body]) newIH
</code></pre>
<p>In addition, the information gathered from the match is preserved, so that when performing the
proof by induction, the user can reliably enter the right case. To achieve this</p>
<ul>
<li>the matcher is replaced by its splitter, which brings extra assumptions into scope when
patterns are overlapping (using <code>matcherApp.transform (useSplitter := true)</code>)</li>
<li>simple discriminants that are mentioned in the goal (i.e plain parameters) are instantiated
in the goal.</li>
<li>for discriminants that are not instantiated that way, equalities connecting the discriminant
to the instantiation are added (just as if the user wrote <code>match h : x with …</code>)</li>
<li>also, simple discriminants (<code>FVars</code>) are remembered as <code>toClear</code>, as they are unlikely to
provide useful context, and are redundant given the context that comes from the pattern match.</li>
</ul>
</li>
<li><p>When a tail position (no more branching) is found, function <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code> assembles the
type of the case: a fresh <code>MVar</code> asserts the current goal, unwanted values from the local context
are cleared, and the current <code>body</code> is searched for recursive calls using <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect">foldAndCollect</a></code>,
which are then asserted as inductive hyptheses in the <code>MVar</code>.</p>
</li>
<li><p>The function <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect">foldAndCollect</a></code> walks the term and performs two operations:</p>
<ul>
<li>collects the induction hypotheses for the current case (with proofs).</li>
<li>recovering the recursive calls</li>
</ul>
<p>So when it encounters a saturated application of <code>oldIH arg proof</code>, it</p>
<ul>
<li>returns <code>f arg</code> and</li>
<li>remembers the expression <code>newIH arg proof : motive x</code> as an inductive hypothesis.</li>
</ul>
<p>Since <code>arg</code> and <code>proof</code> can contain further recursive calls, they are folded there as well.
This assumes that the termination proof <code>proof</code> works nevertheless.</p>
<p>Again, <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect">foldAndCollect</a></code> may encounter the <code>Lean.Meta.Matcherapp.addArg?</code> idiom, and again it
threads <code>newIH</code> through, replacing the extra argument. The resulting type of this induction
hypothesis is now itself a <code>match</code> statement (cf. <code><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.inferMatchType">Lean.Meta.MatcherApp.inferMatchType</a></code>)</p>
<p>The termination proof of <code>foo</code> may have abstracted over some proofs; these proofs must be
transferred, so auxiliary lemmas are unfolded if needed.</p>
</li>
<li><p>After this construction, the MVars introduced by <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code> are turned into parameters.</p>
</li>
</ol><p>The resulting term then becomes <code>foo.induct</code> at its inferred type.</p><h2 class="markdown-heading" id="Implementation-overview-mutual-non-unary-well-founded-recursion">Implementation overview (mutual/non-unary well-founded recursion) <a class="hover-link" href="#Implementation-overview-mutual-non-unary-well-founded-recursion">#</a></h2><p>If <code>foo</code> is not unary and/or part of a mutual reduction, then the induction theorem for <code>foo._unary</code>
(i.e. the unary non-mutual recursion function produced by the equation compiler)
of the form</p><pre><code>foo._unary.induct : {motive : (a ⊗' b) ⊕' c → Prop} →
  (case1 : ∀ …, motive (PSum.inl (x,y)) →  …) → … →
  (x : (a ⊗' b) ⊕' c) → motive x
</code></pre><p>will first in <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction">unpackMutualInduction</a></code> be turned into a joint induction theorem of the form</p><pre><code>foo.mutual_induct : {motive1 : a → b → Prop} {motive2 : c → Prop} →
  (case1 : ∀ …, motive1 x y  →  …) → … →
  ((x : a) → (y : b) → motive1 x y) ∧ ((z : c) → motive2 z)
</code></pre><p>where all the <code><a href="../../.././Init/Core.html#PSum">PSum</a></code>/<code><a href="../../.././Init/Core.html#PSigma">PSigma</a></code> encoding has been resolved. This theorem is attached to the
name of the first function in the mutual group, like the <code>._unary</code> definition.</p><p>Finally, in <code>deriveUnpackedInduction</code>, for each of the functions in the mutual group, a simple
projection yields the final <code>foo.induct</code> theorem:</p><pre><code>foo.induct : {motive1 : a → b → Prop} {motive2 : c → Prop} →
  (case1 : ∀ …, motive1 x y  →  …) → … →
  (x : a) → (y : b) → motive1 x y
</code></pre><h2 class="markdown-heading" id="Implementation-overview-structural-recursion">Implementation overview (structural recursion) <a class="hover-link" href="#Implementation-overview-structural-recursion">#</a></h2><p>When handling structural recursion, the overall approach is the same, with the following
differences:</p><ul>
<li><p>Instead of <code><a href="../../.././Init/WF.html#WellFounded.fix">WellFounded.fix</a></code> we look for a <code>.brecOn</code> application, using <code>isBRecOnRecursor</code></p>
<p>Despite its name, this function does <em>not</em> recognize the <code>.brecOn</code> of inductive <em>predicates</em>,
which we also do not support at this point.</p>
<p>Since (for now) we only support <code>Prop</code> in the induction principle, we rewrite to <code>.binductionOn</code>.</p>
</li>
<li><p>The elaboration of structurally recursive function can handle extra arguments. We keep the
<code>motive</code> parameters in the original order.</p>
</li>
</ul><h2 class="markdown-heading" id="Unfolding-principles">Unfolding principles <a class="hover-link" href="#Unfolding-principles">#</a></h2><p>The code can also create a variant of the induction/cases principles that automatially unfolds
the function application. It's motive abstracts over the function call, so for the ackermann
function one gets</p><pre><code>ackermann.fun_cases_unfolding
  (motive : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → Prop)
  (case1 : ∀ (m : Nat), motive 0 m (m + 1))
  (case2 : ∀ (n : Nat), motive n.succ 0 (ackermann n 1))
  (case3 : ∀ (n m : Nat), motive n.succ m.succ (ackermann n (ackermann (n + 1) m)))
  (x✝ x✝¹ : Nat) : motive x✝ x✝¹ (ackermann x✝ x✝¹)
</code></pre><p>To implement this, in the inital goal <code>motive x (ackermann x)</code> of <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code> we unfold the
function definition, and then reduce is as we go into match, ite or let expressions, using the
<code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive">withRewrittenMotive</a></code> function.</p><p>This gives us great control over the reduction, for example to move <code>let</code> expressions to the context
simultaneously.</p><p>The combinators passed to <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive">withRewrittenMotive</a></code> are forgiving, so when <code>unfolding := false</code>, or when
something goes wrong, one still gets a useful induction principle, just maybe with the function
not fully simplified.</p></div><div class="decl" id="Lean.Tactic.FunInd.lambdaTelescope1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L212-L216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.lambdaTelescope1"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">lambdaTelescope1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> → <a href="../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Lean/Exception.html#Lean.MonadError">MonadError</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Meta.html#Lean.MonadNameGenerator">MonadNameGenerator</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a> → <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.lambdaTelescope1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L228-L235">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A monad to help collecting inductive hypothesis.</p><p>In <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect">foldAndCollect</a></code> it's a writer monad (with variants of the <code>local</code> combinator),
and in <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code> it is more of a reader monad, with inductive hypotheses
being passed down (hence the <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.ask">ask</a></code> and <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.branch">branch</a></code> combinator).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">Lean.Tactic.FunInd.M</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Control/State.html#StateT">StateT</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L241-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run">run</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Control/State.html#StateT.run">StateT.run</a> <span class="fn">act</span> <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.eval"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L242-L242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.eval"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.eval">eval</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run">run</a></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Init/Prelude.html#Prod.fst">fst</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.eval" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.exec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L243-L243">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.exec"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">exec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.exec">exec</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.run">run</a></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.exec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.tell"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L245-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.tell"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">tell</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.tell">Lean.Tactic.FunInd.M.tell</a> <span class="fn">x</span> <span class="fn">xs</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn"><span class="fn">xs</span>.<a href="../../.././Init/Prelude.html#Array.push">push</a></span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.tell" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.localM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L247-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localM"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">localM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.localM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.localMapM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L252-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localMapM"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">localMapM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localMapM">Lean.Tactic.FunInd.M.localMapM</a> <span class="fn">f</span> <span class="fn">act</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localM">Lean.Tactic.FunInd.M.localM</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>) =&gt; <span class="fn"><a href="../../.././Init/Data/Array/Basic.html#Array.mapM">Array.mapM</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">act</span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.localMapM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.ask"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L255-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.ask"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">ask</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.ask">Lean.Tactic.FunInd.M.ask</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#MonadState.get">get</a></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.ask" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M.branch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L257-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.branch"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span>.<span class="name">branch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.branch">branch</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.localM">Lean.Tactic.FunInd.M.localM</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a></span>)</span> <span class="fn">act</span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M.branch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.foldAndCollect"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L262-L423">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">foldAndCollect</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">oldIH </span><span class="fn">newIH</span> : <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isRecCall</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">M</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>The <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldAndCollect">foldAndCollect</a></code> function performs two operations together:</p><ul>
<li>it fold recursive calls: applications (and projectsions) of <code>oldIH</code> in <code>e</code> correspond to
recursive calls, so this function rewrites that back to recursive calls</li>
<li>it collects induction hypotheses: after replacing <code>oldIH</code> with <code>newIH</code>, applications thereof
are valuable as induction hypotheses for the cases.</li>
</ul><p>For well-founded recursion (unary, non-mutual by construction) the terms are rather simple: they
are <code>oldIH arg proof</code>, and can be rewritten to <code>f arg</code> resp. <code>newIH arg proof</code>. But for
structural recursion this can be a more complicted mix of function applications (due to reflexive
data types or extra function arguments) and <code><a href="../../.././Init/Prelude.html#PProd">PProd</a></code> projections (due to the below construction and
mutual function packing), and the main function argument isn't even present.</p><p>To avoid having to think about this, we apply a nice trick:</p><p>We compositionally replace <code>oldIH</code> with <code>newIH</code>. This likely changes the result type, so when
re-assembling we have to be supple (mainly around <code><a href="../../.././Init/Prelude.html#PProd.fst">PProd.fst</a></code>/<code><a href="../../.././Init/Prelude.html#PProd.snd">PProd.snd</a></code>). As we re-assemble
the term we check if it has type <code>motive xs..</code>. If it has, then know we have just found and
rewritten a recursive call, and this type nicely provides us the arguments <code>xs</code>. So at this point
we store the rewritten expression as a new induction hypothesis (using <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.tell">M.tell</a></code>) and rewrite to
<code>f xs..</code>, which now again has the same type as the original term, and the further re-assembly should
work. Half this logic is in the <code>isRecCall</code> parameter.</p><p>If this process fails we’ll get weird type errors (caught later on). We'll see if we need to
improve the errors, for example by passing down a flag whether we expect the same type (and no
occurrences of <code>newIH</code>), or whether we are in “supple mode”, and catch it earlier if the rewriting
fails.</p></div></div><div class="decl" id="Lean.Tactic.FunInd.deduplicateIHs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L429-L437">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deduplicateIHs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">vals</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deduplicateIHs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.assertIHs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L439-L443">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">assertIHs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">vals</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarid</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.assertIHs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanupAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L445-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">index</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span></div></div><p>Goal cleanup:
Substitutes equations (with <code>substVar</code>) to remove superfluous variables, and clears unused
let bindings.</p><p>Substitutes from the outside in so that the inner-bound variable name wins, but does a first pass
looking only at variables with names with macro scope, so that preferably they disappear.</p><p>Careful to only touch the context after the motives (given by the index) as the motive could depend
on anything before, and <code>substVar</code> would happily drop equations about these fixed parameters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.cleanupAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanupAfter.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L461-L465">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.go"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">index</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">firstPass</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span></div></div></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanupAfter.allHeqToEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L467-L474">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.allHeqToEq"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">allHeqToEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">index</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.cleanupAfter.allHeqToEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L476-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanupAfter</span>.<span class="name">cleanupAfter?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">index</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">firstPass</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.cleanupAfter.cleanupAfter?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L491-L494">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Second helper monad collecting the cases as mvars</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">Lean.Tactic.FunInd.M2</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Control/State.html#StateT">StateT</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span> <a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">Lean.Tactic.FunInd.M</a> <span class="fn">α</span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M2" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M2.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L496-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.run"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">act</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.run">run</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Control/State.html#StateT.run">StateT.run</a> <span class="fn">act</span> <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span>.<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M.eval">eval</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M2.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M2.branch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L499-L500">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2.branch"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M2</span>.<span class="name">branch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M2.branch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.buildInductionCase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L503-L519">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionCase</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">oldIH </span><span class="fn">newIH</span> : <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isRecCall</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toErase </span><span class="fn">toClear</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal </span><span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Base case of <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code>: Construct a case for the final induction hypthesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.buildInductionCase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.mkLambdaFVarsMasked"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L521-L547">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkLambdaFVarsMasked</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></div></div><p>Like <code>mkLambdaFVars (usedOnly := true)</code>, but</p><ul>
<li>silently skips expression in <code>xs</code> that are not <code>.isFVar</code></li>
<li>returns a mask (same size as <code>xs</code>) indicating which variables have been abstracted
(<code>true</code> means was abstracted).</li>
</ul><p>The result <code>r</code> can be applied with <code>r.beta (maskArray mask args)</code>.</p><p>We use this when generating the functional induction principle to refine the goal through a <code>match</code>,
here <code>xs</code> are the discriminants of the <code>match</code>.
We do not expect non-trivial discriminants to appear in the goal (and if they do, the user will
get a helpful equality into the context).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.mkLambdaFVarsMasked" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.maskArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L549-L554">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">maskArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mask</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p><code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray">maskArray</a> mask xs</code> keeps those <code>x</code> where the corresponding entry in <code>mask</code> is <code>true</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.maskArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.withRewrittenMotive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L556-L563">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withRewrittenMotive</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rw</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Applies <code>rw</code> to <code>goal</code>, passes the rewritten <code>goal'</code> to <code>k</code> (which should return an expression of
type <code>goal'</code>), and wraps that using the proof from <code>rw</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive">Lean.Tactic.FunInd.withRewrittenMotive</a> <span class="fn">goal</span> <span class="fn">rw</span> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">r</span> ← <span class="fn"><a href="../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn">rw</span> <span class="fn">goal</span>)</span></span>
  let <span class="fn">e</span> ← <span class="fn"><span class="fn">k</span> <span class="fn"><span class="fn">r</span>.<a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.expr">expr</a></span></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">r</span>.<a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.mkEqMPR">mkEqMPR</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.withRewrittenMotive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.inLastArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L565-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">inLastArg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rw</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg">Lean.Tactic.FunInd.inLastArg</a> <span class="fn">rw</span> <span class="fn">(<span class="fn"><span class="fn">goalFn</span>.<a href="../../.././Lean/Expr.html#Lean.Expr.app">app</a></span> <span class="fn">arg</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">r</span> ← <span class="fn"><span class="fn">rw</span> <span class="fn">arg</span></span>
  <span class="fn"><a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.mkCongrArg">Lean.Meta.Simp.mkCongrArg</a> <span class="fn">goalFn</span> <span class="fn">r</span></span></span></li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg">Lean.Tactic.FunInd.inLastArg</a> <span class="fn">rw</span> <span class="fn">goal</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">goal</span> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.inLastArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.withRewrittenMotiveArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L573-L579">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotiveArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withRewrittenMotiveArg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rw</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>If <code>goal</code> is of the form <code>motive a b e</code>, applies <code>rw</code> to <code>e</code>, passes the simplified
<code>goal'</code> to <code>k</code> (which should return an expression of type <code>goal'</code>), and rewrites that term
accordingly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotiveArg">Lean.Tactic.FunInd.withRewrittenMotiveArg</a> <span class="fn">goal</span> <span class="fn">rw</span> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withRewrittenMotive">Lean.Tactic.FunInd.withRewrittenMotive</a> <span class="fn">goal</span> <span class="fn">(<a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inLastArg">Lean.Tactic.FunInd.inLastArg</a> <span class="fn">rw</span>)</span> <span class="fn">k</span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.withRewrittenMotiveArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.inProdLambdaLastArg"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L581-L594">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.inProdLambdaLastArg"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">inProdLambdaLastArg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rw</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><p>Use to write inside the packed motives used for mutual structural recursion.</p></div></div><div class="decl" id="Lean.Tactic.FunInd.rwIfWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L596-L627">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwIfWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwIfWith</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hc </span><span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.rwIfWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.rwLetWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L629-L633">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwLetWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwLetWith</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h </span><span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.rwLetWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.rwHaveWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L635-L639">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwHaveWith"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwHaveWith</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h </span><span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.rwHaveWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.rwFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L641-L651">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwFun"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwFun</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">names</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.rwFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.rwMatcher"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L653-L667">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.rwMatcher"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">rwMatcher</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Meta.Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.rwMatcher" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.buildInductionBody"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L669-L807">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionBody</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">toErase </span><span class="fn">toClear</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">oldIH </span><span class="fn">newIH</span> : <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isRecCall</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M2">M2</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Builds an expression of type <code>goal</code> by replicating the expression <code>e</code> into its tail-call-positions,
where it calls <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code>. Collects the cases of the final induction hypothesis
as <code>MVars</code> as it goes.</p></div></div><div class="decl" id="Lean.Tactic.FunInd.abstractIndependentMVars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L809-L842">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">abstractIndependentMVars</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvars</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">index</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Given an expression <code>e</code> with metavariables <code>mvars</code></p><ul>
<li>performs more cleanup:<ul>
<li>removes unused let-expressions after index <code>index</code></li>
<li>tries to substitute variables after index <code>index</code></li>
</ul>
</li>
<li>lifts them to the current context by reverting all local declarations after index <code>index</code></li>
<li>introducing a local variable for each of the meta variable</li>
<li>assigning that local variable to the mvar</li>
<li>and finally lambda-abstracting over these new local variables.</li>
</ul><p>This operation only works if the metavariables are independent from each other.</p><p>The resulting meta variable assignment is no longer valid (mentions out-of-scope
variables), so after this operations, terms that still mention these meta variables must not
be used anymore.</p><p>We are not using <code>mkLambdaFVars</code> on mvars directly, nor <code>abstractMVars</code>, as these at the moment
do not handle delayed assignments correctly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.abstractIndependentMVars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveUnaryInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L844-L951">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Given a unary definition <code>foo</code> defined via <code><a href="../../.././Init/WF.html#WellFounded.fixF">WellFounded.fixF</a></code>, derive a suitable induction principle
<code>foo.induct</code> for it. See module doc for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveUnaryInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveUnaryInduction.doRealize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L852-L951">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span>.<span class="name">doRealize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name </span><span class="fn">inductName</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveUnaryInduction.doRealize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.projectMutualInduct"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L953-L971">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.projectMutualInduct"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">projectMutualInduct</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">names</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mutualInduct</span> : <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">finalizeFirstInd</span> : <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a realizer for <code>foo.mutual_induct</code>, defines <code>foo.induct</code>, <code>bar.induct</code> etc.
Used for well-founded and structural recursion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.projectMutualInduct" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.setNaryFunIndInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L973-L995">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.setNaryFunIndInfo"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">setNaryFunIndInfo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fixedParamPerms</span> : <a href="../../.././Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms">Elab.FixedParamPerms</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name </span><span class="fn">unaryInduct</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>For a (non-mutual!) definition of <code>name</code>, uses the <code>FunIndInfo</code> associated with the <code>unaryInduct</code> and
derives the one for the n-ary function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.setNaryFunIndInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanPackedArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L997-L1053">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanPackedArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">eqnInfo</span> : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">value</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>In the type of <code>value</code>, reduces</p><ul>
<li>Beta-redexes</li>
<li><code><a href="../../.././Init/Core.html#PSigma.casesOn">PSigma.casesOn</a> (PSigma.mk a b) (fun x y =&gt; k x y)  --&gt;  k a b</code></li>
<li><code><a href="../../.././Init/Core.html#PSum.casesOn">PSum.casesOn</a> (PSum.inl x) k₁ k₂                    --&gt;  k₁ x</code></li>
<li><code>foo._unary (PSum.inl (PSigma.mk a b))              --&gt;  foo a b</code>
and then wraps <code>value</code> in an appropriate type hint.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.cleanPackedArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.unpackMutualInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1055-L1107">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eqnInfo</span> : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Retrieves <code>foo._unary.induct</code>, where the motive is a <code><a href="../../.././Init/Core.html#PSigma">PSigma</a></code>/<code><a href="../../.././Init/Core.html#PSum">PSum</a></code> type, and
unpacks it into a n-ary and (possibly) joint induction principle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.unpackMutualInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.unpackMutualInduction.doRealize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1067-L1107">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span>.<span class="name">doRealize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eqnInfo</span> : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inductName</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.unpackMutualInduction.doRealize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.withLetDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1109-L1118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withLetDecls</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ts </span><span class="fn">es</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.withLetDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.withLetDecls.go"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1113-L1118">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.withLetDecls.go"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">withLetDecls</span>.<span class="name">go</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ts </span><span class="fn">es</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.withLetDecls.go" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveInductionStructural"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1120-L1357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInductionStructural</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">names</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fixedParamPerms</span> : <a href="../../.././Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms">Elab.FixedParamPerms</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Given a recursive definition <code>foo</code> defined via structural recursion, derive <code>foo.mutual_induct</code>,
if needed, and <code>foo.induct</code> for all functions in the group.
See module doc for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveInductionStructural" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveInductionStructural.doRealize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1133-L1357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInductionStructural.doRealize"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInductionStructural</span>.<span class="name">doRealize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">names</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fixedParamPerms</span> : <a href="../../.././Lean/Elab/PreDefinition/FixedParams.html#Lean.Elab.FixedParamPerms">Elab.FixedParamPerms</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inductName</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveInductionStructural.doRealize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1360-L1431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveCases"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveCases</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>For non-recursive (and recursive functions) functions we derive a “functional case splitting theorem”. This is very similar
than the functional induction theorem. It splits the goal, but does not give you inductive hyptheses.</p><p>For these, it is not really clear which parameters should be “targets” of the motive, as there is
no “fixed prefix” to guide this decision. All? None? Some?</p><p>We tried none, but that did not work well. Right now it's all parameters, and it seems to work well.
In the future, we might post-process the theorem (or run the code below iteratively) and remove
targets that are unchanged in each case, so simplify applying the lemma when these “fixed” parameters
are not variables, to avoid having to generalize them.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1433-L1455">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInduction</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">unfolding</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a recursively defined function <code>foo</code>, derives <code>foo.induct</code>. See the module doc for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.isFunInductName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1457-L1475">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunInductName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName">Lean.Tactic.FunInd.isFunInductName</a> <span class="fn">env</span> <span class="fn">(<span class="fn"><span class="fn">indName</span>.<a href="../../.././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">str</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName">Lean.Tactic.FunInd.isFunInductName</a> <span class="fn">env</span> <span class="fn">name</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.isFunInductName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.isFunCasesName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Lean/Meta/Tactic/FunInd.lean#L1478-L1489">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunCasesName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunCasesName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunCasesName">Lean.Tactic.FunInd.isFunCasesName</a> <span class="fn">env</span> <span class="fn">(<span class="fn"><span class="fn">indName</span>.<a href="../../.././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">str</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunCasesName">Lean.Tactic.FunInd.isFunCasesName</a> <span class="fn">env</span> <span class="fn">name</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.isFunCasesName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>