<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Core</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Core";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Core</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Prelude.html">Init.Prelude</a></li><li><a href=".././Init/SizeOf.html">Init.SizeOf</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Core" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#inline"><span class="name">inline</span></a></div><div class="nav_link"><a class="break_within" href="#id_def"><span class="name">id_def</span></a></div><div class="nav_link"><a class="break_within" href="#flip"><span class="name">flip</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_def"><span class="name">Function</span>.<span class="name">comp_def</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_comp"><span class="name">Function</span>.<span class="name">const_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_const"><span class="name">Function</span>.<span class="name">comp_const</span></a></div><div class="nav_link"><a class="break_within" href="#Function.true_comp"><span class="name">Function</span>.<span class="name">true_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.false_comp"><span class="name">Function</span>.<span class="name">false_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Empty.elim"><span class="name">Empty</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqEmpty"><span class="name">instDecidableEqEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#PEmpty.elim"><span class="name">PEmpty</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPEmpty"><span class="name">instDecidableEqPEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk"><span class="name">Thunk</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#thunkCoe"><span class="name">thunkCoe</span></a></div><div class="nav_link"><a class="break_within" href="#Iff"><span class="name">Iff</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;-&gt;_»"><span class="name">«term_&lt;-&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_↔_»"><span class="name">«term_↔_»</span></a></div><div class="nav_link"><a class="break_within" href="#Sum"><span class="name">Sum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕_»"><span class="name">«term_⊕_»</span></a></div><div class="nav_link"><a class="break_within" href="#PSum"><span class="name">PSum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></div><div class="nav_link"><a class="break_within" href="#PSum.inhabitedLeft"><span class="name">PSum</span>.<span class="name">inhabitedLeft</span></a></div><div class="nav_link"><a class="break_within" href="#PSum.inhabitedRight"><span class="name">PSum</span>.<span class="name">inhabitedRight</span></a></div><div class="nav_link"><a class="break_within" href="#PSum.nonemptyLeft"><span class="name">PSum</span>.<span class="name">nonemptyLeft</span></a></div><div class="nav_link"><a class="break_within" href="#PSum.nonemptyRight"><span class="name">PSum</span>.<span class="name">nonemptyRight</span></a></div><div class="nav_link"><a class="break_within" href="#Sigma"><span class="name">Sigma</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma"><span class="name">PSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Exists"><span class="name">Exists</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep"><span class="name">ForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn"><span class="name">ForIn</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn'"><span class="name">ForIn'</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPRBC"><span class="name">DoResultPRBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPR"><span class="name">DoResultPR</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultBC"><span class="name">DoResultBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultSBC"><span class="name">DoResultSBC</span></a></div><div class="nav_link"><a class="break_within" href="#HasEquiv"><span class="name">HasEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≈_»"><span class="name">«term_≈_»</span></a></div><div class="nav_link"><a class="break_within" href="#HasSubset"><span class="name">HasSubset</span></a></div><div class="nav_link"><a class="break_within" href="#HasSSubset"><span class="name">HasSSubset</span></a></div><div class="nav_link"><a class="break_within" href="#Superset"><span class="name">Superset</span></a></div><div class="nav_link"><a class="break_within" href="#SSuperset"><span class="name">SSuperset</span></a></div><div class="nav_link"><a class="break_within" href="#Union"><span class="name">Union</span></a></div><div class="nav_link"><a class="break_within" href="#Inter"><span class="name">Inter</span></a></div><div class="nav_link"><a class="break_within" href="#SDiff"><span class="name">SDiff</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊆_»"><span class="name">«term_⊆_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊂_»"><span class="name">«term_⊂_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊇_»"><span class="name">«term_⊇_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊃_»"><span class="name">«term_⊃_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∪_»"><span class="name">«term_∪_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∩_»"><span class="name">«term_∩_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_\_»"><span class="name">«term_\_»</span></a></div><div class="nav_link"><a class="break_within" href="#EmptyCollection"><span class="name">EmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#«term{}»"><span class="name">«term{}»</span></a></div><div class="nav_link"><a class="break_within" href="#«term∅»"><span class="name">«term∅»</span></a></div><div class="nav_link"><a class="break_within" href="#Insert"><span class="name">Insert</span></a></div><div class="nav_link"><a class="break_within" href="#Singleton"><span class="name">Singleton</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulSingleton"><span class="name">LawfulSingleton</span></a></div><div class="nav_link"><a class="break_within" href="#insert_emptyc_eq"><span class="name">insert_emptyc_eq</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulSingleton.insert_emptyc_eq"><span class="name">LawfulSingleton</span>.<span class="name">insert_emptyc_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Sep"><span class="name">Sep</span></a></div><div class="nav_link"><a class="break_within" href="#Task"><span class="name">Task</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTask"><span class="name">instInhabitedTask</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyTask"><span class="name">instNonemptyTask</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></div><div class="nav_link"><a class="break_within" href="#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></div><div class="nav_link"><a class="break_within" href="#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#NonScalar"><span class="name">NonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#PNonScalar"><span class="name">PNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></div><div class="nav_link"><a class="break_within" href="#optParam_eq"><span class="name">optParam_eq</span></a></div><div class="nav_link"><a class="break_within" href="#strictOr"><span class="name">strictOr</span></a></div><div class="nav_link"><a class="break_within" href="#strictAnd"><span class="name">strictAnd</span></a></div><div class="nav_link"><a class="break_within" href="#bne"><span class="name">bne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_!=_»"><span class="name">«term_!=_»</span></a></div><div class="nav_link"><a class="break_within" href="#ReflBEq"><span class="name">ReflBEq</span></a></div><div class="nav_link"><a class="break_within" href="#BEq.rfl"><span class="name">BEq</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#BEq.refl"><span class="name">BEq</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#beq_of_eq"><span class="name">beq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#not_eq_of_beq_eq_false"><span class="name">not_eq_of_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulBEq"><span class="name">LawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqBool"><span class="name">instLawfulBEqBool</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEq"><span class="name">instLawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqOfLawfulBEq"><span class="name">instDecidableEqOfLawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqChar"><span class="name">instLawfulBEqChar</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqString"><span class="name">instLawfulBEqString</span></a></div><div class="nav_link"><a class="break_within" href="#trivial"><span class="name">trivial</span></a></div><div class="nav_link"><a class="break_within" href="#mt"><span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#not_false"><span class="name">not_false</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_intro"><span class="name">not_not_intro</span></a></div><div class="nav_link"><a class="break_within" href="#proof_irrel"><span class="name">proof_irrel</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></div><div class="nav_link"><a class="break_within" href="#cast_eq"><span class="name">cast_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Ne"><span class="name">Ne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≠_»"><span class="name">«term_≠_»</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_comm"><span class="name">ne_comm</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_ne"><span class="name">false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_false_of_self"><span class="name">ne_false_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#ne_true_of_not"><span class="name">ne_true_of_not</span></a></div><div class="nav_link"><a class="break_within" href="#true_ne_false"><span class="name">true_ne_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_ne_true"><span class="name">false_ne_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></div><div class="nav_link"><a class="break_within" href="#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq"><span class="name">heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq"><span class="name">eqRec_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq_iff"><span class="name">eqRec_heq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#heq_eqRec_iff"><span class="name">heq_eqRec_iff</span></a></div><div class="nav_link"><a class="break_within" href="#apply_eqRec"><span class="name">apply_eqRec</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#cast_heq"><span class="name">cast_heq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#instTransIff"><span class="name">instTransIff</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.comm"><span class="name">Eq</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#eq_comm"><span class="name">eq_comm</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.comm"><span class="name">HEq</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#heq_comm"><span class="name">heq_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_comm"><span class="name">iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.symm"><span class="name">And</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#and_comm"><span class="name">and_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Or.symm"><span class="name">Or</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Or.comm"><span class="name">Or</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#or_comm"><span class="name">or_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#decide_true"><span class="name">decide_true</span></a></div><div class="nav_link"><a class="break_within" href="#decide_false"><span class="name">decide_false</span></a></div><div class="nav_link"><a class="break_within" href="#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing"><span class="name">toBoolUsing</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#of_toBoolUsing_eq_true"><span class="name">of_toBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#of_toBoolUsing_eq_false"><span class="name">of_toBoolUsing_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableTrue"><span class="name">instDecidableTrue</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFalse"><span class="name">instDecidableFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableForall"><span class="name">instDecidableForall</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIff"><span class="name">instDecidableIff</span></a></div><div class="nav_link"><a class="break_within" href="#if_pos"><span class="name">if_pos</span></a></div><div class="nav_link"><a class="break_within" href="#if_neg"><span class="name">if_neg</span></a></div><div class="nav_link"><a class="break_within" href="#iteInduction"><span class="name">iteInduction</span></a></div><div class="nav_link"><a class="break_within" href="#dif_pos"><span class="name">dif_pos</span></a></div><div class="nav_link"><a class="break_within" href="#dif_neg"><span class="name">dif_neg</span></a></div><div class="nav_link"><a class="break_within" href="#dif_eq_if"><span class="name">dif_eq_if</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIte"><span class="name">instDecidableIte</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableDite"><span class="name">instDecidableDite</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionEnum"><span class="name">noConfusionEnum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProp"><span class="name">instInhabitedProp</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></div><div class="nav_link"><a class="break_within" href="#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton"><span class="name">Subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingleton"><span class="name">instSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonEmpty"><span class="name">instSubsingletonEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonPEmpty"><span class="name">instSubsingletonPEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonProd"><span class="name">instSubsingletonProd</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></div><div class="nav_link"><a class="break_within" href="#recSubsingleton"><span class="name">recSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence"><span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#emptyRelation"><span class="name">emptyRelation</span></a></div><div class="nav_link"><a class="break_within" href="#Subrelation"><span class="name">Subrelation</span></a></div><div class="nav_link"><a class="break_within" href="#InvImage"><span class="name">InvImage</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen"><span class="name">Relation</span>.<span class="name">TransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.exists_of_subtype"><span class="name">Subtype</span>.<span class="name">exists_of_subtype</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instBEq"><span class="name">Subtype</span>.<span class="name">instBEq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instReflBEq"><span class="name">Subtype</span>.<span class="name">instReflBEq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instLawfulBEq"><span class="name">Subtype</span>.<span class="name">instLawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instDecidableEq"><span class="name">Subtype</span>.<span class="name">instDecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.nonemptyLeft"><span class="name">Sum</span>.<span class="name">nonemptyLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.nonemptyRight"><span class="name">Sum</span>.<span class="name">nonemptyRight</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyProd"><span class="name">instNonemptyProd</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyMProd"><span class="name">instNonemptyMProd</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyPProd"><span class="name">instNonemptyPProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProd"><span class="name">instInhabitedProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#instBEqProd"><span class="name">instBEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_apply"><span class="name">Prod</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_fst"><span class="name">Prod</span>.<span class="name">map_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_snd"><span class="name">Prod</span>.<span class="name">map_snd</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.of_psigma_prop"><span class="name">Exists</span>.<span class="name">of_psigma_prop</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid"><span class="name">Setoid</span></a></div><div class="nav_link"><a class="break_within" href="#instHasEquivOfSetoid"><span class="name">instHasEquivOfSetoid</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#propext"><span class="name">propext</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqOfIff"><span class="name">instDecidableEqOfIff</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ.inj"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ.injEq"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">injEq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_iff_eq"><span class="name">beq_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Not.elim"><span class="name">Not</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#And.elim"><span class="name">And</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.elim"><span class="name">Iff</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Not.intro"><span class="name">Not</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp"><span class="name">Not</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_congr"><span class="name">not_congr</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_not"><span class="name">not_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_true"><span class="name">iff_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_false"><span class="name">iff_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_left"><span class="name">iff_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_right"><span class="name">iff_true_right</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_left"><span class="name">iff_false_left</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_right"><span class="name">iff_false_right</span></a></div><div class="nav_link"><a class="break_within" href="#of_iff_true"><span class="name">of_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_intro"><span class="name">iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_true_of_subsingleton"><span class="name">eq_iff_true_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#not_of_iff_false"><span class="name">not_of_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_intro"><span class="name">iff_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_false_intro"><span class="name">not_iff_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#not_true"><span class="name">not_true</span></a></div><div class="nav_link"><a class="break_within" href="#not_false_iff"><span class="name">not_false_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.to_iff"><span class="name">Eq</span>.<span class="name">to_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_eq"><span class="name">iff_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#neq_of_not_iff"><span class="name">neq_of_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_eq"><span class="name">iff_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_iff"><span class="name">eq_iff_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_self_iff_true"><span class="name">eq_self_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#ne_self_iff_false"><span class="name">ne_self_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_true_iff_false"><span class="name">false_of_true_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_true_eq_false"><span class="name">false_of_true_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#true_eq_false_of_false"><span class="name">true_eq_false_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_def"><span class="name">iff_def</span></a></div><div class="nav_link"><a class="break_within" href="#iff_def'"><span class="name">iff_def'</span></a></div><div class="nav_link"><a class="break_within" href="#true_iff_false"><span class="name">true_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_iff_true"><span class="name">false_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_self"><span class="name">iff_not_self</span></a></div><div class="nav_link"><a class="break_within" href="#heq_self_iff_true"><span class="name">heq_self_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_of_not_imp"><span class="name">not_not_of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_of_not_imp"><span class="name">not_of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_not_self"><span class="name">imp_not_self</span></a></div><div class="nav_link"><a class="break_within" href="#imp_intro"><span class="name">imp_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_imp_imp"><span class="name">imp_imp_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right"><span class="name">imp_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#imp_true_iff"><span class="name">imp_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#false_imp_iff"><span class="name">false_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#true_imp_iff"><span class="name">true_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#imp_self"><span class="name">imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#imp_false"><span class="name">imp_false</span></a></div><div class="nav_link"><a class="break_within" href="#imp.swap"><span class="name">imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_not_comm"><span class="name">imp_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_left"><span class="name">imp_congr_left</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_right"><span class="name">imp_congr_right</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx"><span class="name">imp_congr_ctx</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr"><span class="name">imp_congr</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not"><span class="name">imp_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient"><span class="name">Quotient</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.decidableEq"><span class="name">Quotient</span>.<span class="name">decidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#funext"><span class="name">funext</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.pliftOn"><span class="name">Quot</span>.<span class="name">pliftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.pliftOn"><span class="name">Quotient</span>.<span class="name">pliftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.instSubsingleton"><span class="name">Pi</span>.<span class="name">instSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Squash"><span class="name">Squash</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.trustCompiler"><span class="name">Lean</span>.<span class="name">trustCompiler</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.opaqueId"><span class="name">Lean</span>.<span class="name">opaqueId</span></a></div><div class="nav_link"><a class="break_within" href="#ge_iff_le"><span class="name">ge_iff_le</span></a></div><div class="nav_link"><a class="break_within" href="#gt_iff_lt"><span class="name">gt_iff_lt</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_eq_of_le"><span class="name">le_of_eq_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_le_of_eq"><span class="name">le_of_le_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#lt_of_eq_of_lt"><span class="name">lt_of_eq_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#lt_of_lt_of_eq"><span class="name">lt_of_lt_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Associative"><span class="name">Std</span>.<span class="name">Associative</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Commutative"><span class="name">Std</span>.<span class="name">Commutative</span></a></div><div class="nav_link"><a class="break_within" href="#Std.IdempotentOp"><span class="name">Std</span>.<span class="name">IdempotentOp</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulLeftIdentity"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulRightIdentity"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Identity"><span class="name">Std</span>.<span class="name">Identity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulIdentity"><span class="name">Std</span>.<span class="name">LawfulIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulCommIdentity"><span class="name">Std</span>.<span class="name">LawfulCommIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeOr"><span class="name">Std</span>.<span class="name">instCommutativeOr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeAnd"><span class="name">Std</span>.<span class="name">instCommutativeAnd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeIff"><span class="name">Std</span>.<span class="name">instCommutativeIff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Refl"><span class="name">Std</span>.<span class="name">Refl</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Antisymm"><span class="name">Std</span>.<span class="name">Antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Antisymm"><span class="name">Antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Asymm"><span class="name">Std</span>.<span class="name">Asymm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Total"><span class="name">Std</span>.<span class="name">Total</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Irrefl"><span class="name">Std</span>.<span class="name">Irrefl</span></a></div></nav><main>
<div class="decl" id="inline"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L17-L22">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#inline"><span class="name">inline</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Core.html#inline">inline</a> (f x)</code> is an indication to the compiler to inline the definition of <code>f</code>
at the application site itself (by comparison to the <code>@[inline]</code> attribute,
which applies to all applications of the function).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#inline">inline</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-inline" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="id_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L24-L24">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#id_def"><span class="name">id_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="flip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L28-L35">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#flip"><span class="name">flip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">φ</span></span></span></div></div><p><code><a href=".././Init/Core.html#flip">flip</a> f a b</code> is <code>f b a</code>. It is useful for &quot;point-free&quot; programming,
since it can sometimes be used to avoid introducing variables.
For example, <code>(·&lt;·)</code> is the less-than relation,
and <code><a href=".././Init/Core.html#flip">flip</a> (·&lt;·)</code> is the greater-than relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#flip">flip</a> <span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-flip" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.const_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L37-L37">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Function.const">const</a> <span class="fn">α</span> <span class="fn">y</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Function.comp_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L39-L39">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span>) <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></div></div></div></div><div class="decl" id="Function.comp_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L41-L41">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_def"><span class="name">Function</span>.<span class="name">comp_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.const_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L43-L45">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.const_comp"><span class="name">Function</span>.<span class="name">const_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Function.const">const</a> <span class="fn">β</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Function.const">const</a> <span class="fn">α</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Function.comp_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L46-L48">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_const"><span class="name">Function</span>.<span class="name">comp_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><a href=".././Init/Prelude.html#Function.const">const</a> <span class="fn">α</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Function.const">const</a> <span class="fn">α</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Function.true_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L49-L50">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.true_comp"><span class="name">Function</span>.<span class="name">true_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <a href=".././Init/Prelude.html#Bool.true">true</a>)</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Function.false_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L51-L52">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.false_comp"><span class="name">Function</span>.<span class="name">false_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <a href=".././Init/Prelude.html#Bool.false">false</a>)</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Empty.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L56-L60">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Empty.elim"><span class="name">Empty</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Empty">Empty</a> → <span class="fn">C</span></span></div></div><p><code><a href=".././Init/Core.html#Empty.elim">Empty.elim</a> : <a href=".././Init/Prelude.html#Empty">Empty</a> → C</code> says that a value of any type can be constructed from
<code><a href=".././Init/Prelude.html#Empty">Empty</a></code>. This can be thought of as a compiler-checked assertion that a code path is unreachable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">t</span>.<a href=".././Init/Core.html#Empty.elim">elim</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Empty.rec">Empty.rec</a> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Empty">Empty</a>) =&gt; <span class="fn">C</span>)</span> <span class="fn">t</span></span></li></ul></details><details id="instances-for-list-Empty.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L62-L63">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqEmpty"><span class="name">instDecidableEqEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Empty">Empty</a></span></div></div><p>Decidable equality for Empty</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqEmpty">instDecidableEqEmpty</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Core.html#Empty.elim">elim</a></span></li></ul></details></div></div><div class="decl" id="PEmpty.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L65-L69">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PEmpty.elim"><span class="name">PEmpty</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#PEmpty">PEmpty</a> → <span class="fn">C</span></span></div></div><p><code><a href=".././Init/Core.html#PEmpty.elim">PEmpty.elim</a> : <a href=".././Init/Prelude.html#Empty">Empty</a> → C</code> says that a value of any type can be constructed from
<code><a href=".././Init/Prelude.html#PEmpty">PEmpty</a></code>. This can be thought of as a compiler-checked assertion that a code path is unreachable.</p><details><summary>Equations</summary><ul class="equations"></ul></details><details id="instances-for-list-PEmpty.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqPEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqPEmpty"><span class="name">instDecidableEqPEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a></span></div></div><p>Decidable equality for PEmpty</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqPEmpty">instDecidableEqPEmpty</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Core.html#PEmpty.elim">elim</a></span></li></ul></details></div></div><div class="decl" id="Thunk"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L74-L93">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk"><span class="name">Thunk</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Delays evaluation. The delayed code is evaluated at most once.</p><p>A thunk is code that constructs a value when it is requested via <code><a href=".././Init/Core.html#Thunk.get">Thunk.get</a></code>, <code><a href=".././Init/Core.html#Thunk.map">Thunk.map</a></code>, or
<code><a href=".././Init/Core.html#Thunk.bind">Thunk.bind</a></code>. The resulting value is cached, so the code is executed at most once. This is also
known as lazy or call-by-need evaluation.</p><p>The Lean runtime has special support for the <code><a href=".././Init/Core.html#Thunk">Thunk</a></code> type in order to implement the caching
behavior.</p><ul class="structure_fields" id="Thunk.mk"><li id="_private.Init.Core.0.Thunk.fn" class="structure_field"><div class="structure_field_info">fn : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Extract the getter function out of a thunk. Use <code><a href=".././Init/Core.html#Thunk.get">Thunk.get</a></code> instead.</p></div></li></ul><details id="instances-for-list-Thunk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L97-L103">source</a></div><div class="attributes">@[extern  lean_thunk_pure]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span></div></div><p>Stores an already-computed value in a thunk.</p><p>Because the value has already been computed, there is no laziness.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Thunk.pure">Thunk.pure</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Thunk.mk">{</a> <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">a</span></span> <a href=".././Init/Core.html#Thunk.mk">}</a></li></ul></details><details id="instances-for-list-Thunk.pure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L105-L113">source</a></div><div class="attributes">@[extern  lean_thunk_get_own]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Gets the thunk's value. If the value is cached, it is returned in constant time; if not, it is
computed.</p><p>Computed values are cached, so the value is not recomputed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Thunk.get">get</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#_private.Init.Core.0.Thunk.fn">Thunk.fn✝</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a></span></li></ul></details><details id="instances-for-list-Thunk.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L115-L120">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Constructs a new thunk that forces <code>x</code> and then applies <code>x</code> to the result. Upon forcing, the result
of <code>f</code> is cached and the reference to the thunk <code>x</code> is dropped.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Thunk.map">Thunk.map</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Thunk.mk">{</a> <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x_1</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Thunk.get">get</a></span></span></span> <a href=".././Init/Core.html#Thunk.mk">}</a></li></ul></details><details id="instances-for-list-Thunk.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L122-L126">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Constructs a new thunk that applies <code>f</code> to the result of <code>x</code> when forced.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Thunk.bind">bind</a></span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Thunk.mk">{</a> <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x_1</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Thunk.get">get</a></span>)</span>.<a href=".././Init/Core.html#Thunk.get">get</a></span></span> <a href=".././Init/Core.html#Thunk.mk">}</a></li></ul></details><details id="instances-for-list-Thunk.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.sizeOf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L128-L129">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/SizeOf.html#SizeOf">SizeOf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">1</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Core.html#Thunk.get">get</a></span></span></div></div></div></div><div class="decl" id="thunkCoe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L131-L133">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#thunkCoe"><span class="name">thunkCoe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#CoeTail">CoeTail</a> <span class="fn">α</span> <span class="fn">(<a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#thunkCoe">thunkCoe</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Coe.html#CoeTail.mk">{</a> <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Core.html#Thunk.mk">{</a> <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">a</span></span> <a href=".././Init/Core.html#Thunk.mk">}</a></span> <a href=".././Init/Coe.html#CoeTail.mk">}</a></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="definitions">definitions <a class="hover-link" href="#definitions">#</a></h1></div><div class="decl" id="Iff"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L141-L152">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff"><span class="name">Iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>↔</code> in identifiers is <code>iff</code>.</p>
</li>
<li><p>The recommended spelling of <code>&lt;-&gt;</code> in identifiers is <code>iff</code> (prefer <code>↔</code> over <code>&lt;-&gt;</code>).</p>
</li>
</ul><ul class="structure_ext"><li id="Iff.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Iff.mp" class="structure_field"><div class="structure_field_info">mp : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div><div class="structure_field_doc"><p>Modus ponens for if and only if. If <code>a ↔ b</code> and <code>a</code>, then <code>b</code>.</p></div></li><li id="Iff.mpr" class="structure_field"><div class="structure_field_info">mpr : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div><div class="structure_field_doc"><p>Modus ponens for if and only if, reversed. If <code>a ↔ b</code> and <code>b</code>, then <code>a</code>.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-Iff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;-&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L154-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_&lt;-&gt;_»"><span class="name">«term_&lt;-&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;-&gt;</code> in identifiers is <code>iff</code> (prefer <code>↔</code> over <code>&lt;-&gt;</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_&lt;-&gt;_»">«term_&lt;-&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;-&gt;_»</span> <span class="fn">20</span> <span class="fn">21</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;-&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;-&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_↔_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L155-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_↔_»"><span class="name">«term_↔_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>↔</code> in identifiers is <code>iff</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_↔_»">«term_↔_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_↔_»</span> <span class="fn">20</span> <span class="fn">21</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ↔ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_↔_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L161-L173">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum"><span class="name">Sum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>The disjoint union of types <code>α</code> and <code>β</code>, ordinarily written <code>α ⊕ β</code>.</p><p>An element of <code>α ⊕ β</code> is either an <code>a : α</code> wrapped in <code><a href=".././Init/Core.html#Sum.inl">Sum.inl</a></code> or a <code>b : β</code> wrapped in <code><a href=".././Init/Core.html#Sum.inr">Sum.inr</a></code>.
<code>α ⊕ β</code> is not equivalent to the set-theoretic union of <code>α</code> and <code>β</code> because its values include an
indication of which of the two types was chosen. The union of a singleton set with itself contains
one element, while <code><a href=".././Init/Prelude.html#Unit">Unit</a> ⊕ <a href=".././Init/Prelude.html#Unit">Unit</a></code> contains distinct values <code><a href=".././Init/Core.html#Sum.inl">inl</a> ()</code> and <code><a href=".././Init/Core.html#Sum.inr">inr</a> ()</code>.</p><ul class="constructors"><li class="constructor" id="Sum.inl">inl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕ β</code>.</p></div></li><li class="constructor" id="Sum.inr">inr<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">β</span>)</span></span>
 : <span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕ β</code>.</p></div></li></ul><details id="instances-for-list-Sum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊕_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L175-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕_»"><span class="name">«term_⊕_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The disjoint union of types <code>α</code> and <code>β</code>, ordinarily written <code>α ⊕ β</code>.</p><p>An element of <code>α ⊕ β</code> is either an <code>a : α</code> wrapped in <code><a href=".././Init/Core.html#Sum.inl">Sum.inl</a></code> or a <code>b : β</code> wrapped in <code><a href=".././Init/Core.html#Sum.inr">Sum.inr</a></code>.
<code>α ⊕ β</code> is not equivalent to the set-theoretic union of <code>α</code> and <code>β</code> because its values include an
indication of which of the two types was chosen. The union of a singleton set with itself contains
one element, while <code><a href=".././Init/Prelude.html#Unit">Unit</a> ⊕ <a href=".././Init/Prelude.html#Unit">Unit</a></code> contains distinct values <code><a href=".././Init/Core.html#Sum.inl">inl</a> ()</code> and <code><a href=".././Init/Core.html#Sum.inr">inr</a> ()</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊕_»">«term_⊕_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊕_»</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊕ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊕_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L177-L189">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum"><span class="name">PSum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p>The disjoint union of arbitrary sorts <code>α</code> <code>β</code>, or <code>α ⊕' β</code>.</p><p>It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts <code>Sort u</code> and <code>Sort v</code>,
instead of restricting them to <code>Type u</code> and <code>Type v</code>. This means that it can be used in situations
where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>. However, the resulting universe level
constraints are often more difficult to solve than those that result from <code><a href=".././Init/Core.html#Sum">Sum</a></code>.</p><ul class="constructors"><li class="constructor" id="PSum.inl">inl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕' β</code>.</p></div></li><li class="constructor" id="PSum.inr">inr<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">β</span>)</span></span>
 : <span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕' β</code>.</p></div></li></ul><details id="instances-for-list-PSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊕'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L191-L191">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The disjoint union of arbitrary sorts <code>α</code> <code>β</code>, or <code>α ⊕' β</code>.</p><p>It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts <code>Sort u</code> and <code>Sort v</code>,
instead of restricting them to <code>Type u</code> and <code>Type v</code>. This means that it can be used in situations
where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>. However, the resulting universe level
constraints are often more difficult to solve than those that result from <code><a href=".././Init/Core.html#Sum">Sum</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊕'_»">«term_⊕'_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊕'_»</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊕' &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊕'_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSum.inhabitedLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L193-L199">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum.inhabitedLeft"><span class="name">PSum</span>.<span class="name">inhabitedLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></div></div><p>If the left type in a sum is inhabited then the sum is inhabited.</p><p>This is not an instance to avoid non-canonical instances when both the left and right types are
inhabited.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#PSum.inhabitedLeft">PSum.inhabitedLeft</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PSum.inl">PSum.inl</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details><details id="instances-for-list-PSum.inhabitedLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSum.inhabitedRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L201-L207">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum.inhabitedRight"><span class="name">PSum</span>.<span class="name">inhabitedRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></div></div><p>If the right type in a sum is inhabited then the sum is inhabited.</p><p>This is not an instance to avoid non-canonical instances when both the left and right types are
inhabited.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#PSum.inhabitedRight">PSum.inhabitedRight</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PSum.inr">PSum.inr</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details><details id="instances-for-list-PSum.inhabitedRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSum.nonemptyLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L209-L210">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum.nonemptyLeft"><span class="name">PSum</span>.<span class="name">nonemptyLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="PSum.nonemptyRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L212-L213">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum.nonemptyRight"><span class="name">PSum</span>.<span class="name">nonemptyRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="Sigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L215-L239">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sigma"><span class="name">Sigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Dependent pairs, in which the second element's type depends on the value of the first element. The
type <code><a href=".././Init/Core.html#Sigma">Sigma</a> β</code> is typically written <code>Σ a : α, β a</code> or <code>(a : α) × β a</code>.</p><p>Although its values are pairs, <code><a href=".././Init/Core.html#Sigma">Sigma</a></code> is sometimes known as the <em>dependent sum type</em>, since it is
the type level version of an indexed summation.</p><ul class="structure_fields" id="Sigma.mk"><li id="Sigma.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first component of a dependent pair.</p></div></li><li id="Sigma.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">self</span>.<a href=".././Init/Core.html#Sigma.fst">fst</a></span></span></div><div class="structure_field_doc"><p>The second component of a dependent pair. Its type depends on the first component.</p></div></li></ul><details id="instances-for-list-Sigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L243-L268">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma"><span class="name">PSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p>Fully universe-polymorphic dependent pairs, in which the second element's type depends on the value
of the first element and both types are allowed to be propositions. The type <code><a href=".././Init/Core.html#PSigma">PSigma</a> β</code> is typically
written <code>Σ' a : α, β a</code> or <code>(a : α) ×' β a</code>.</p><p>In practice, this generality leads to universe level constraints that are difficult to solve, so
<code><a href=".././Init/Core.html#PSigma">PSigma</a></code> is rarely used in manually-written code. It is usually only used in automation that
constructs pairs of arbitrary types.</p><p>To pair a value with a proof that a predicate holds for it, use <code><a href=".././Init/Prelude.html#Subtype">Subtype</a></code>. To demonstrate that a
value exists that satisfies a predicate, use <code><a href=".././Init/Core.html#Exists">Exists</a></code>. A dependent pair with a proposition as its
first component is not typically useful due to proof irrelevance: there's no point in depending on a
specific proof because all proofs are equal anyway.</p><ul class="structure_fields" id="PSigma.mk"><li id="PSigma.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first component of a dependent pair.</p></div></li><li id="PSigma.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">self</span>.<a href=".././Init/Core.html#PSigma.fst">fst</a></span></span></div><div class="structure_field_doc"><p>The second component of a dependent pair. Its type depends on the first component.</p></div></li></ul><details id="instances-for-list-PSigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Exists"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L270-L298">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists"><span class="name">Exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Existential quantification. If <code>p : α → Prop</code> is a predicate, then <code>∃ x : α, p x</code>
asserts that there is some <code>x</code> of type <code>α</code> such that <code>p x</code> holds.
To create an existential proof, use the <code>exists</code> tactic,
or the anonymous constructor notation <code>⟨x, h⟩</code>.
To unpack an existential, use <code>cases h</code> where <code>h</code> is a proof of <code>∃ x : α, p x</code>,
or <code>let ⟨x, hx⟩ := h</code> where `.</p><p>Because Lean has proof irrelevance, any two proofs of an existential are
definitionally equal. One consequence of this is that it is impossible to recover the
witness of an existential from the mere fact of its existence.
For example, the following does not compile:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#Nat">Nat</a> :=
  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`
  x
</code></pre><p>The error message <code>recursor 'Exists.casesOn' can only eliminate into Prop</code> means
that this only works when the current goal is another proposition:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#True">True</a> :=
  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`
  <a href=".././Init/Core.html#trivial">trivial</a>
</code></pre><ul class="constructors"><li class="constructor" id="Exists.intro">intro<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">w</span></span>)</span></span>
 : <span class="fn"><a href=".././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span><div class="inductive_ctor_doc"><p>Existential introduction. If <code>a : α</code> and <code>h : p a</code>,
then <code>⟨a, h⟩</code> is a proof that <code>∃ x : α, p x</code>.</p></div></li></ul><details id="instances-for-list-Exists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ForInStep"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L300-L321">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForInStep"><span class="name">ForInStep</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>An indication of whether a loop's body terminated early that's used to compile the <code>for x in xs</code>
notation.</p><p>A collection's <code><a href=".././Init/Core.html#ForIn">ForIn</a></code> or <code><a href=".././Init/Core.html#ForIn'">ForIn'</a></code> instance describe's how to iterate over its elements. The monadic
action that represents the body of the loop returns a <code><a href=".././Init/Core.html#ForInStep">ForInStep</a> α</code>, where <code>α</code> is the local state
used to implement features such as <code>let mut</code>.</p><ul class="constructors"><li class="constructor" id="ForInStep.done">done<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span><div class="inductive_ctor_doc"><p>The loop should terminate early.</p><p><code><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a></code> is produced by uses of <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> in the loop body.</p></div></li><li class="constructor" id="ForInStep.yield">yield<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span><div class="inductive_ctor_doc"><p>The loop should continue with the next iteration, using the returned state.</p><p><code><a href=".././Init/Core.html#ForInStep.yield">ForInStep.yield</a></code> is produced by <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> and by reaching the bottom of the loop body.</p></div></li></ul><details id="instances-for-list-ForInStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedForInStep"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L321-L321">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a✝</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a✝</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedForInStep">instInhabitedForInStep</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="ForIn"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L323-L345">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn"><span class="name">ForIn</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (max u (u₁ + 1)) u₂) v)</div></div><p>Monadic iteration in <code>do</code>-blocks, using the <code>for x in xs</code> notation.</p><p>The parameter <code>m</code> is the monad of the <code>do</code>-block in which iteration is performed, <code>ρ</code> is the type of
the collection being iterated over, and <code>α</code> is the type of elements.</p><ul class="structure_fields" id="ForIn.mk"><li id="ForIn.forIn" class="structure_field"><div class="structure_field_info">forIn<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></div><div class="structure_field_doc"><p>Monadically iterates over the contents of a collection <code>xs</code>, with a local state <code>b</code> and the
possibility of early termination.</p><p>Because a <code>do</code> block supports local mutable bindings along with <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code>, and <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code>, the monadic
action passed to <code><a href=".././Init/Core.html#ForIn.forIn">ForIn.forIn</a></code> takes a starting state in addition to the current element of the
collection and returns an updated state together with an indication of whether iteration should
continue or terminate. If the action returns <code><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a></code>, then <code><a href=".././Init/Core.html#ForIn.forIn">ForIn.forIn</a></code> should stop
iteration and return the updated state. If the action returns <code><a href=".././Init/Core.html#ForInStep.yield">ForInStep.yield</a></code>, then
<code><a href=".././Init/Core.html#ForIn.forIn">ForIn.forIn</a></code> should continue iterating if there are further elements, passing the updated state
to the action.</p><p>More information about the translation of <code>for</code> loops into <code><a href=".././Init/Core.html#ForIn.forIn">ForIn.forIn</a></code> is available in <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=monad-iteration-syntax">the Lean
reference manual</a>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn" class="instances-list"></ul></details></div></div><div class="decl" id="ForIn'"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L349-L373">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn'"><span class="name">ForIn'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> v)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">(<a href=".././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (max u (u₁ + 1)) u₂) v)</div></div><p>Monadic iteration in <code>do</code>-blocks with a membership proof, using the <code>for h : x in xs</code> notation.</p><p>The parameter <code>m</code> is the monad of the <code>do</code>-block in which iteration is performed, <code>ρ</code> is the type of
the collection being iterated over, <code>α</code> is the type of elements, and <code>d</code> is the specific membership
predicate to provide.</p><ul class="structure_fields" id="ForIn'.mk"><li id="ForIn'.forIn'" class="structure_field"><div class="structure_field_info">forIn'<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></div><div class="structure_field_doc"><p>Monadically iterates over the contents of a collection <code>xs</code>, with a local state <code>b</code> and the
possibility of early termination. At each iteration, the body of the loop is provided with a proof
that the current element is in the collection.</p><p>Because a <code>do</code> block supports local mutable bindings along with <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code>, and <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code>, the monadic
action passed to <code><a href=".././Init/Core.html#ForIn'.forIn'">ForIn'.forIn'</a></code> takes a starting state in addition to the current element of the
collection with its membership proof. The action returns an updated state together with an
indication of whether iteration should continue or terminate. If the action returns
<code><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a></code>, then <code><a href=".././Init/Core.html#ForIn'.forIn'">ForIn'.forIn'</a></code> should stop iteration and return the updated state. If the
action returns <code><a href=".././Init/Core.html#ForInStep.yield">ForInStep.yield</a></code>, then <code><a href=".././Init/Core.html#ForIn'.forIn'">ForIn'.forIn'</a></code> should continue iterating if there are
further elements, passing the updated state to the action.</p><p>More information about the translation of <code>for</code> loops into <code><a href=".././Init/Core.html#ForIn'.forIn'">ForIn'.forIn'</a></code> is available in <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=monad-iteration-syntax">the
Lean reference manual</a>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn'" class="instances-list"></ul></details></div></div><div class="decl" id="DoResultPRBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L377-L400">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPRBC"><span class="name">DoResultPRBC</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is used when compiling a do block
nested inside a combinator like <code>tryCatch</code>. It encodes the possible ways the
block can exit:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code>.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop.</li>
</ul><p>All cases return a value <code>s : σ</code> which bundles all the mutable variables of the do-block.</p><ul class="constructors"><li class="constructor" id="DoResultPRBC.pure">pure<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div></li><li class="constructor" id="DoResultPRBC.return">return<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div></li><li class="constructor" id="DoResultPRBC.break">break<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultPRBC.continue">continue<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultPRBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultPR"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L402-L411">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPR"><span class="name">DoResultPR</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is the same as
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α β σ</code> except that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> and <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> are not available
because we are not in a loop context.</p><ul class="constructors"><li class="constructor" id="DoResultPR.pure">pure<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div></li><li class="constructor" id="DoResultPR.return">return<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div></li></ul><details id="instances-for-list-DoResultPR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L413-L424">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultBC"><span class="name">DoResultBC</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> to remove the impossible cases,
used when neither <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> nor <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> are possible exit paths.</p><ul class="constructors"><li class="constructor" id="DoResultBC.break">break<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultBC.continue">continue<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultSBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L426-L443">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultSBC"><span class="name">DoResultSBC</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
either <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> or <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> α σ</code> to remove the
impossible case, used when either <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> is never used.</p><ul class="constructors"><li class="constructor" id="DoResultSBC.pureReturn">pureReturn<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p>This encodes either <code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α)</code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (a : α)</code>:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</li>
</ul><p>The one that is actually encoded depends on the context of use.</p></div></li><li class="constructor" id="DoResultSBC.break">break<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultSBC.continue">continue<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultSBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HasEquiv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L445-L449">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasEquiv"><span class="name">HasEquiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max u (v + 1))</div></div><p><code><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> α</code> is the typeclass which supports the notation <code>x ≈ y</code> where <code>x y : α</code>.</p><ul class="structure_fields" id="HasEquiv.mk"><li id="HasEquiv.Equiv" class="structure_field"><div class="structure_field_info">Equiv : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span></div><div class="structure_field_doc"><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≈</code> in identifiers is <code>equiv</code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasEquiv" class="instances-list"></ul></details></div></div><div class="decl" id="«term_≈_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L451-L451">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≈_»"><span class="name">«term_≈_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≈</code> in identifiers is <code>equiv</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_≈_»">«term_≈_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_≈_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≈ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_≈_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="set-notation">set notation <a class="hover-link" href="#set-notation">#</a></h1></div><div class="decl" id="HasSubset"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L457-L460">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasSubset"><span class="name">HasSubset</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the subset relation <code>⊆</code>.</p><ul class="structure_fields" id="HasSubset.mk"><li id="HasSubset.Subset" class="structure_field"><div class="structure_field_info">Subset : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Subset relation: <code>a ⊆ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊆</code> in identifiers is <code>subset</code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasSubset" class="instances-list"></ul></details></div></div><div class="decl" id="HasSSubset"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L463-L466">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasSSubset"><span class="name">HasSSubset</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the strict subset relation <code>⊂</code>.</p><ul class="structure_fields" id="HasSSubset.mk"><li id="HasSSubset.SSubset" class="structure_field"><div class="structure_field_info">SSubset : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Strict subset relation: <code>a ⊂ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊂</code> in identifiers is <code>ssubset</code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasSSubset" class="instances-list"></ul></details></div></div><div class="decl" id="Superset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L469-L470">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Superset"><span class="name">Superset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#HasSubset">HasSubset</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Superset relation: <code>a ⊇ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊇</code> in identifiers is <code>superset</code> (prefer <code>⊆</code> over <code>⊇</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Core.html#Superset">⊇</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b</span> <a href=".././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">a</span>)</li></ul></details><details id="instances-for-list-Superset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="SSuperset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L472-L473">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#SSuperset"><span class="name">SSuperset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#HasSSubset">HasSSubset</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Strict superset relation: <code>a ⊃ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊃</code> in identifiers is <code>ssuperset</code> (prefer <code>⊂</code> over <code>⊃</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Core.html#SSuperset">⊃</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b</span> <a href=".././Init/Core.html#HasSSubset.SSubset">⊂</a> <span class="fn">a</span>)</li></ul></details><details id="instances-for-list-SSuperset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Union"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L475-L478">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Union"><span class="name">Union</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the union operation <code>∪</code>.</p><ul class="structure_fields" id="Union.mk"><li id="Union.union" class="structure_field"><div class="structure_field_info">union : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ∪ b</code> is the union of<code>a</code> and <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∪</code> in identifiers is <code><a href=".././Init/Core.html#Union.union">union</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Union" class="instances-list"></ul></details></div></div><div class="decl" id="Inter"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L480-L483">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Inter"><span class="name">Inter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the intersection operation <code>∩</code>.</p><ul class="structure_fields" id="Inter.mk"><li id="Inter.inter" class="structure_field"><div class="structure_field_info">inter : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ∩ b</code> is the intersection of<code>a</code> and <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∩</code> in identifiers is <code><a href=".././Init/Core.html#Inter.inter">inter</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Inter" class="instances-list"></ul></details></div></div><div class="decl" id="SDiff"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L485-L491">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#SDiff"><span class="name">SDiff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the set difference <code>\</code>.</p><ul class="structure_fields" id="SDiff.mk"><li id="SDiff.sdiff" class="structure_field"><div class="structure_field_info">sdiff : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a \ b</code> is the set difference of <code>a</code> and <code>b</code>,
consisting of all elements in <code>a</code> that are not in <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>\</code> in identifiers is <code><a href=".././Init/Core.html#SDiff.sdiff">sdiff</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SDiff" class="instances-list"></ul></details></div></div><div class="decl" id="«term_⊆_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L493-L494">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊆_»"><span class="name">«term_⊆_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Subset relation: <code>a ⊆ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊆</code> in identifiers is <code>subset</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊆_»">«term_⊆_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊆_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊆ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊆_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊂_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L496-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊂_»"><span class="name">«term_⊂_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Strict subset relation: <code>a ⊂ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊂</code> in identifiers is <code>ssubset</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊂_»">«term_⊂_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊂_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊂ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊂_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊇_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L499-L500">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊇_»"><span class="name">«term_⊇_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Superset relation: <code>a ⊇ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊇</code> in identifiers is <code>superset</code> (prefer <code>⊆</code> over <code>⊇</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊇_»">«term_⊇_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊇_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊇ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊇_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊃_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L502-L503">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊃_»"><span class="name">«term_⊃_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Strict superset relation: <code>a ⊃ b</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⊃</code> in identifiers is <code>ssuperset</code> (prefer <code>⊂</code> over <code>⊃</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_⊃_»">«term_⊃_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⊃_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊃ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⊃_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∪_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_∪_»"><span class="name">«term_∪_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ∪ b</code> is the union of<code>a</code> and <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∪</code> in identifiers is <code><a href=".././Init/Core.html#Union.union">union</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_∪_»">«term_∪_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∪_»</span> <span class="fn">65</span> <span class="fn">65</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∪ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∪_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∩_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_∩_»"><span class="name">«term_∩_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ∩ b</code> is the intersection of<code>a</code> and <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∩</code> in identifiers is <code><a href=".././Init/Core.html#Inter.inter">inter</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_∩_»">«term_∩_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∩_»</span> <span class="fn">70</span> <span class="fn">70</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∩ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∩_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_\_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L511-L515">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_\_»"><span class="name">«term_\_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a \ b</code> is the set difference of <code>a</code> and <code>b</code>,
consisting of all elements in <code>a</code> that are not in <code>b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>\</code> in identifiers is <code><a href=".././Init/Core.html#SDiff.sdiff">sdiff</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_\_»">«term_\_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_\_»</span> <span class="fn">70</span> <span class="fn">71</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; \\ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_\_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="collections">collections <a class="hover-link" href="#collections">#</a></h1></div><div class="decl" id="EmptyCollection"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L529-L533">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#EmptyCollection"><span class="name">EmptyCollection</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> α</code> is the typeclass which supports the notation <code>∅</code>, also written as <code>{}</code>.</p><ul class="structure_fields" id="EmptyCollection.mk"><li id="EmptyCollection.emptyCollection" class="structure_field"><div class="structure_field_info">emptyCollection : <span class="fn">α</span></div><div class="structure_field_doc"><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>{}</code> in identifiers is <code>empty</code>.</p>
</li>
<li><p>The recommended spelling of <code>∅</code> in identifiers is <code>empty</code>.</p>
</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-EmptyCollection" class="instances-list"></ul></details></div></div><div class="decl" id="«term{}»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L535-L535">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term{}»"><span class="name">«term{}»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>{}</code> in identifiers is <code>empty</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term{}»">«term{}»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term{}»</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;{&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;}&quot;</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term{}»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term∅»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L536-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term∅»"><span class="name">«term∅»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∅</code> in identifiers is <code>empty</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term∅»">«term∅»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term∅»</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;∅&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«term∅»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Insert"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L541-L547">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Insert"><span class="name">Insert</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class for the <code><a href=".././Init/Core.html#Insert.insert">insert</a></code> operation.
Used to implement the <code>{ a, b, c }</code> syntax.</p><ul class="structure_fields" id="Insert.mk"><li id="Insert.insert" class="structure_field"><div class="structure_field_info">insert : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x xs</code> inserts the element <code>x</code> into the collection <code>xs</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Insert" class="instances-list"></ul></details></div></div><div class="decl" id="Singleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L550-L556">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Singleton"><span class="name">Singleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class for the <code><a href=".././Init/Core.html#Singleton.singleton">singleton</a></code> operation.
Used to implement the <code>{ a, b, c }</code> syntax.</p><ul class="structure_fields" id="Singleton.mk"><li id="Singleton.singleton" class="structure_field"><div class="structure_field_info">singleton : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Singleton.singleton">singleton</a> x</code> is a collection with the single element <code>x</code> (notation: <code>{x}</code>).</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>{x}</code> in identifiers is <code><a href=".././Init/Core.html#Singleton.singleton">singleton</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Singleton" class="instances-list"></ul></details></div></div><div class="decl" id="LawfulSingleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L559-L563">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulSingleton"><span class="name">LawfulSingleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x ∅ = {x}</code></p><ul class="structure_fields" id="LawfulSingleton.mk"><li id="LawfulSingleton.insert_empty_eq" class="structure_field"><div class="structure_field_info">insert_empty_eq<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href=".././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <a href=".././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href=".././Init/Core.html#Singleton.singleton">}</a></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x ∅ = {x}</code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LawfulSingleton" class="instances-list"></ul></details></div></div><div class="decl" id="insert_emptyc_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L568-L571">source</a></div><div class="attributes">@[deprecated LawfulSingleton.insert_empty_eq (since := &quot;2025-03-12&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#insert_emptyc_eq"><span class="name">insert_emptyc_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulSingleton">LawfulSingleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <a href=".././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href=".././Init/Core.html#Singleton.singleton">}</a></div></div></div></div><div class="decl" id="LawfulSingleton.insert_emptyc_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L573-L576">source</a></div><div class="attributes">@[deprecated LawfulSingleton.insert_empty_eq (since := &quot;2025-03-12&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulSingleton.insert_emptyc_eq"><span class="name">LawfulSingleton</span>.<span class="name">insert_emptyc_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulSingleton">LawfulSingleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <a href=".././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href=".././Init/Core.html#Singleton.singleton">}</a></div></div></div></div><div class="decl" id="Sep"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L579-L582">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sep"><span class="name">Sep</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class used to implement the notation <code>{ a ∈ c | p a }</code></p><ul class="structure_fields" id="Sep.mk"><li id="Sep.sep" class="structure_field"><div class="structure_field_info">sep : <span class="fn"><span class="fn">(<span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a>)</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p>Computes <code>{ a ∈ c | p a }</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Sep" class="instances-list"></ul></details></div></div><div class="decl" id="Task"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L584-L610">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task"><span class="name">Task</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#Task">Task</a> α</code> is a primitive for asynchronous computation.
It represents a computation that will resolve to a value of type <code>α</code>,
possibly being computed on another thread. This is similar to <code>Future</code> in Scala,
<code>Promise</code> in Javascript, and <code>JoinHandle</code> in Rust.</p><p>The tasks have an overridden representation in the runtime.</p><ul class="structure_ext"><li id="Task.pure" class="structure_ext_ctor">pure :: (</li><ul class="structure_ext_fields"><li id="Task.get" class="structure_field"><div class="structure_field_info">get : <span class="fn">α</span></div><div class="structure_field_doc"><p>Blocks the current thread until the given task has finished execution, and then returns the result
of the task. If the current thread is itself executing a (non-dedicated) task, the maximum
threadpool size is temporarily increased by one while waiting so as to ensure the process cannot
be deadlocked by threadpool starvation. Note that when the current thread is unblocked, more tasks
than the configured threadpool size may temporarily be running at the same time until sufficiently
many tasks have finished.</p><p><code><a href=".././Init/Core.html#Task.map">Task.map</a></code> and <code><a href=".././Init/Core.html#Task.bind">Task.bind</a></code> should be preferred over <code><a href=".././Init/Core.html#Task.get">Task.get</a></code> for setting up task dependencies
where possible as they do not require temporarily growing the threadpool in this way. In
particular, calling <code><a href=".././Init/Core.html#Task.get">Task.get</a></code> in a task continuation with <code>(sync := true)</code> will panic as the
continuation is decidedly not &quot;cheap&quot; in this case and deadlocks may otherwise occur. The
waited-upon task should instead be returned and unwrapped using <code>Task.bind/IO.bindTask</code>.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-Task" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L610-L610">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTask"><span class="name">instInhabitedTask</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a✝</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#Task">Task</a> <span class="fn">a✝</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedTask">instInhabitedTask</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Core.html#Task.pure">{</a> <span class="fn">get</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Core.html#Task.pure">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instNonemptyTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L610-L610">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyTask"><span class="name">instNonemptyTask</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α✝</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α✝</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href=".././Init/Core.html#Task">Task</a> <span class="fn">α✝</span>)</span></span></div></div></div></div><div class="decl" id="Task.Priority"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L616-L622">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Task priority.</p><p>Tasks with higher priority will always be scheduled before tasks with lower priority. Tasks with a
priority greater than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> are scheduled on dedicated threads.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat">Nat</a></li></ul></details><details id="instances-for-list-Task.Priority" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L624-L625">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Priority</a></div></div><p>The default priority for spawned tasks, also the lowest priority: <code>0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li></ul></details><details id="instances-for-list-Task.Priority.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L626-L634">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Priority</a></div></div><p>The highest regular priority for spawned tasks: <code>8</code>.</p><p>Spawning a task with a priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> is not an error but will spawn a
dedicated worker for the task. This is indicated using <code><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a></code>. Regular priority
tasks are placed in a thread pool and worked on according to their priority order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">8</span></li></ul></details><details id="instances-for-list-Task.Priority.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.dedicated"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L635-L643">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Priority</a></div></div><p>Indicates that a task should be scheduled on a dedicated thread.</p><p>Any priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> will result in the task being scheduled
immediately on a dedicated thread. This is particularly useful for long-running and/or
I/O-bound tasks since Lean will, by default, allocate no more non-dedicated workers
than the number of cores to reduce context switches.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">9</span></li></ul></details><details id="instances-for-list-Task.Priority.dedicated" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.spawn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L646-L654">source</a></div><div class="attributes">@[noinline, extern  lean_task_spawn]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">fn</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prio</span> : <a href=".././Init/Core.html#Task.Priority">Priority</a> := <a href=".././Init/Core.html#Task.Priority.default">Priority.default</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span></div></div><p><code><a href=".././Init/Core.html#Task.spawn">spawn</a> fn : <a href=".././Init/Core.html#Task">Task</a> α</code> constructs and immediately launches a new task for
evaluating the function <code>fn () : α</code> asynchronously.</p><p><code>prio</code>, if provided, is the priority of the task.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.spawn">Task.spawn</a> <span class="fn">fn</span> <span class="fn">prio</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Task.pure">{</a> <span class="fn">get</span> := <span class="fn"><span class="fn">fn</span> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a></span> <a href=".././Init/Core.html#Task.pure">}</a></li></ul></details><details id="instances-for-list-Task.spawn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L657-L669">source</a></div><div class="attributes">@[noinline, extern  lean_task_map]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prio</span> : <a href=".././Init/Core.html#Task.Priority">Priority</a> := <a href=".././Init/Core.html#Task.Priority.default">Priority.default</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sync</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.map">map</a> f x</code> maps function <code>f</code> over the task <code>x</code>: that is, it constructs
(and immediately launches) a new task which will wait for the value of <code>x</code> to
be available and then calls <code>f</code> on the result.</p><p><code>prio</code>, if provided, is the priority of the task.
If <code>sync</code> is set to true, <code>f</code> is executed on the current thread if <code>x</code> has already finished and
otherwise on the thread that <code>x</code> finished on. <code>prio</code> is ignored in this case. This should only be
done when executing <code>f</code> is cheap and non-blocking.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.map">Task.map</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">prio</span> <span class="fn">sync</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Task.pure">{</a> <span class="fn">get</span> := <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Task.get">get</a></span></span> <a href=".././Init/Core.html#Task.pure">}</a></li></ul></details><details id="instances-for-list-Task.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L672-L686">source</a></div><div class="attributes">@[noinline, extern  lean_task_bind]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prio</span> : <a href=".././Init/Core.html#Task.Priority">Priority</a> := <a href=".././Init/Core.html#Task.Priority.default">Priority.default</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sync</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.bind">bind</a> x f</code> does a monad &quot;bind&quot; operation on the task <code>x</code> with function <code>f</code>:
that is, it constructs (and immediately launches) a new task which will wait
for the value of <code>x</code> to be available and then calls <code>f</code> on the result,
resulting in a new task which is then run for a result.</p><p><code>prio</code>, if provided, is the priority of the task.
If <code>sync</code> is set to true, <code>f</code> is executed on the current thread if <code>x</code> has already finished and
otherwise on the thread that <code>x</code> finished on. <code>prio</code> is ignored in this case. This should only be
done when executing <code>f</code> is cheap and non-blocking.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Task.bind">bind</a></span> <span class="fn">f</span> <span class="fn">prio</span> <span class="fn">sync</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Task.pure">{</a> <span class="fn">get</span> := <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Core.html#Task.get">get</a></span>)</span>.<a href=".././Init/Core.html#Task.get">get</a></span> <a href=".././Init/Core.html#Task.pure">}</a></li></ul></details><details id="instances-for-list-Task.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="NonScalar"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L690-L698">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#NonScalar"><span class="name">NonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p><code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><ul class="structure_fields" id="NonScalar.mk"><li id="NonScalar.val" class="structure_field"><div class="structure_field_info">val : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>You should not use this function</p></div></li></ul><details id="instances-for-list-NonScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PNonScalar"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L700-L711">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PNonScalar"><span class="name">PNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><p>This is the universe-polymorphic version of <code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code>; it is preferred to use
<code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> instead where applicable.</p><ul class="constructors"><li class="constructor" id="PNonScalar.mk">mk<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href=".././Init/Core.html#PNonScalar">PNonScalar</a><div class="inductive_ctor_doc"><p>You should not use this function</p></div></li></ul><details id="instances-for-list-PNonScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.add_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L713-L713">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="optParam_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L715-L715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#optParam_eq"><span class="name">optParam_eq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">default</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <span class="fn">α</span> <span class="fn">default</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Boolean-operators">Boolean operators <a class="hover-link" href="#Boolean-operators">#</a></h1></div><div class="decl" id="strictOr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L719-L723">source</a></div><div class="attributes">@[extern  lean_strict_or]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictOr"><span class="name">strictOr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">b₁ </span><span class="fn">b₂</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictOr">strictOr</a></code> is the same as <code>or</code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>true</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#strictOr">strictOr</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b₁</span> <a href=".././Init/Prelude.html#Bool.or">||</a> <span class="fn">b₂</span>)</li></ul></details><details id="instances-for-list-strictOr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="strictAnd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L725-L729">source</a></div><div class="attributes">@[extern  lean_strict_and]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictAnd"><span class="name">strictAnd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">b₁ </span><span class="fn">b₂</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictAnd">strictAnd</a></code> is the same as <code>and</code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#strictAnd">strictAnd</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b₁</span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b₂</span>)</li></ul></details><details id="instances-for-list-strictAnd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="bne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L731-L739">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#bne"><span class="name">bne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>!=</code> in identifiers is <code><a href=".././Init/Core.html#bne">bne</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Core.html#bne">!=</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.not">!</a><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></li></ul></details><details id="instances-for-list-bne" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_!=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L741-L741">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_!=_»"><span class="name">«term_!=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>!=</code> in identifiers is <code><a href=".././Init/Core.html#bne">bne</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_!=_»">«term_!=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_!=_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; != &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_!=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ReflBEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L745-L748">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ReflBEq"><span class="name">ReflBEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> α</code> says that the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> implementation is reflexive.</p><ul class="structure_fields" id="ReflBEq.mk"><li id="ReflBEq.rfl" class="structure_field"><div class="structure_field_info">rfl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span> : (<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div><div class="structure_field_doc"><p><code>==</code> is reflexive, that is, <code>(a == a) = true</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ReflBEq" class="instances-list"></ul></details></div></div><div class="decl" id="BEq.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L750-L750">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#BEq.rfl"><span class="name">BEq</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="BEq.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L751-L751">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#BEq.refl"><span class="name">BEq</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="beq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L753-L754">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_of_eq"><span class="name">beq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → (<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="not_eq_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L756-L757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_eq_of_beq_eq_false"><span class="name">not_eq_of_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="LawfulBEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L759-L768">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulBEq"><span class="name">LawfulBEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A Boolean equality test coincides with propositional equality.</p><p>In other words:</p><ul>
<li><code>a == b</code> implies <code>a = b</code>.</li>
<li><code>a == a</code> is true.</li>
</ul><ul class="structure_fields" id="LawfulBEq.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Core.html#ReflBEq.rfl">rfl</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span> : (<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></li><li id="LawfulBEq.eq_of_beq" class="structure_field"><div class="structure_field_info">eq_of_beq<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div><div class="structure_field_doc"><p>If <code>a == b</code> evaluates to <code>true</code>, then <code>a</code> and <code>b</code> are equal in the logic.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LawfulBEq" class="instances-list"></ul></details></div></div><div class="decl" id="instLawfulBEqBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L772-L774">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqBool"><span class="name">instLawfulBEqBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="instLawfulBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L776-L778">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEq"><span class="name">instLawfulBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="instDecidableEqOfLawfulBEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L780-L787">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqOfLawfulBEq"><span class="name">instDecidableEqOfLawfulBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Non-instance for <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a></code> from <code><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a></code>.
To use this, add <code>attribute [local instance 5] <a href=".././Init/Core.html#instDecidableEqOfLawfulBEq">instDecidableEqOfLawfulBEq</a></code> at the top of a file.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqOfLawfulBEq">instDecidableEqOfLawfulBEq</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match h : <span class="fn">x</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span> with
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span>
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-instDecidableEqOfLawfulBEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instLawfulBEqChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L789-L789">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqChar"><span class="name">instLawfulBEqChar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></div></div></div><div class="decl" id="instLawfulBEqString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L791-L791">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqString"><span class="name">instLawfulBEqString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Logical-connectives-and-equality">Logical connectives and equality <a class="hover-link" href="#Logical-connectives-and-equality">#</a></h1></div><div class="decl" id="trivial"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L795-L795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#trivial"><span class="name">trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#True">True</a></div></div><p><code><a href=".././Init/Prelude.html#True">True</a></code> is true, and <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code> (or more commonly, <code><a href=".././Init/Core.html#trivial">trivial</a></code>)
is the proof.</p></div></div><div class="decl" id="mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L797-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#mt"><span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="not_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L800-L800">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_false"><span class="name">not_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="not_not_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L802-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_intro"><span class="name">not_not_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div></div></div><div class="decl" id="proof_irrel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L806-L806">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#proof_irrel"><span class="name">proof_irrel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁ </span><span class="fn">h₂</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">h₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">h₂</span></div></div></div></div><div class="decl" id="Eq.mp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L808-L816">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mp">mp</a> : α → β</code> is the induced
&quot;cast&quot; operation, mapping elements of <code>α</code> to elements of <code>β</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mp">mp</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">h</span>.<a href=".././Init/Core.html#Eq.mp">mp</a></span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">h</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-Eq.mp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Eq.mpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L818-L826">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mpr">mpr</a> : β → α</code> is the induced
&quot;cast&quot; operation in the reverse direction, mapping elements of <code>β</code> to elements of <code>α</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mpr">mpr</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">h</span>.<a href=".././Init/Core.html#Eq.mpr">mpr</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">b</span></li></ul></details><details id="instances-for-list-Eq.mpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Eq.substr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L828-L830">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="cast_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L832-L833">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_eq"><span class="name">cast_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Ne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L835-L840">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne"><span class="name">Ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≠</code> in identifiers is <code>ne</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></li></ul></details><details id="instances-for-list-Ne" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_≠_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L842-L842">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≠_»"><span class="name">«term_≠_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≠</code> in identifiers is <code>ne</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#«term_≠_»">«term_≠_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_≠_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≠ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_≠_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ne.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L850-L850">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Ne.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L852-L852">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Ne.irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L854-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="Ne.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L856-L856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="ne_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L858-L858">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_comm"><span class="name">ne_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L860-L860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_ne"><span class="name">false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="ne_false_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L862-L863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_false_of_self"><span class="name">ne_false_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> → <span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="ne_true_of_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L865-L868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_true_of_not"><span class="name">ne_true_of_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="true_ne_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L870-L870">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_ne_false"><span class="name">true_ne_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="false_ne_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L871-L871">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_ne_true"><span class="name">false_ne_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="Bool.of_not_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L875-L877">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Bool.of_not_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L879-L881">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="ne_of_beq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L883-L884">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="beq_false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L886-L889">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="HEq.ndrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L894-L896">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p>Non-dependent recursor for <code><a href=".././Init/Prelude.html#HEq">HEq</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a> <span class="fn">m</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#HEq.rec">HEq.rec</a> <span class="fn">m</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-HEq.ndrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.ndrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L898-L900">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p><code><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a></code> variant</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#HEq.ndrecOn">HEq.ndrecOn</a> <span class="fn">h</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#HEq.rec">HEq.rec</a> <span class="fn">m</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-HEq.ndrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L902-L904">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div><p><code><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a></code> variant</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">h₁</span>.<a href=".././Init/Core.html#HEq.elim">elim</a></span> <span class="fn">h₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">h₂</span></li></ul></details><details id="instances-for-list-HEq.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L906-L908">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">T</span> : <a href=".././foundational_types.html">Sort</a> u) → <span class="fn"><span class="fn">T</span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">p</span> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">β</span> <span class="fn">b</span></span></div></div><p>Substitution with heterogeneous equality.</p></div></div><div class="decl" id="HEq.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L910-L912">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div><p>Heterogeneous equality is symmetric.</p></div></div><div class="decl" id="heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L914-L916">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq"><span class="name">heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a'</span></span></div></div><p>Propositionally equal terms are also heterogeneously equal.</p></div></div><div class="decl" id="HEq.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L918-L920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">φ</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">φ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">c</span></span></div></div><p>Heterogeneous equality is transitive.</p></div></div><div class="decl" id="heq_of_heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L922-L924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">b'</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b'</span></span></div></div><p>Heterogeneous equality precomposes with propositional equality.</p></div></div><div class="decl" id="heq_of_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L926-L928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a'</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p>Heterogeneous equality postcomposes with propositional equality.</p></div></div><div class="decl" id="type_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L930-L932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></div></div><p>If two terms are heterogeneously equal then their types are propositionally equal.</p></div></div><div class="decl" id="eqRec_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L936-L941">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eqRec_heq"><span class="name">eqRec_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">φ</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<a href=".././Init/Prelude.html#Eq.recOn">Eq.recOn</a> <span class="fn">h</span> <span class="fn">p</span>)</span> <span class="fn">p</span></span></div></div><p>Rewriting inside <code>φ</code> using <code><a href=".././Init/Prelude.html#Eq.recOn">Eq.recOn</a></code> yields a term that's heterogeneously equal to the original
term.</p></div></div><div class="decl" id="eqRec_heq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L943-L950">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eqRec_heq_iff"><span class="name">eqRec_heq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> (<span class="fn">h</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">refl</span>) <span class="fn">c</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">refl</span> <span class="fn">c</span></span></div></div><p>Heterogenous equality with an <code><a href=".././Init/Prelude.html#Eq.rec">Eq.rec</a></code> application on the left is equivalent to a heterogenous
equality on the original term.</p></div></div><div class="decl" id="heq_eqRec_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L952-L959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_eqRec_iff"><span class="name">heq_eqRec_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">c</span> (<span class="fn">h</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">refl</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">c</span> <span class="fn">refl</span></span></div></div><p>Heterogenous equality with an <code><a href=".././Init/Prelude.html#Eq.rec">Eq.rec</a></code> application on the right is equivalent to a heterogenous
equality on the original term.</p></div></div><div class="decl" id="apply_eqRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L961-L969">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#apply_eqRec"><span class="name">apply_eqRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">motive</span> : <span class="fn">(<span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Eq.rec">Eq.rec</a> (motive := <span class="fn">fun (<span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span> → <span class="fn">β</span></span></span>) <span class="fn">c</span> <span class="fn">h</span> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">c</span>
    <span class="fn">(<span class="fn">(fun (<span class="fn">h_1</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>) =&gt;
        <span class="fn"><a href=".././Init/Prelude.html#Eq.ndrec">Eq.ndrec</a> (motive := <span class="fn">fun {<span class="fn">a</span> : <span class="fn">α</span>} =&gt;
          <span class="fn">(<span class="fn">motive</span> : <span class="fn">(<span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>) → <span class="fn">{<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>} → <span class="fn">{<span class="fn">c</span> : <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span> → <span class="fn">β</span></span>} → <span class="fn">{<span class="fn">d</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span>} → <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span></span></span></span>)
          <span class="fn">(fun (<span class="fn">motive</span> : <span class="fn">(<span class="fn">b_1</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b_1</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>) {<span class="fn">h</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>} {<span class="fn">c</span> : <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">⋯</span></span> → <span class="fn">β</span></span>} {<span class="fn">d</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">h</span></span>} =&gt; <span class="fn">d</span>)</span> <span class="fn">h_1</span>
          <span class="fn">motive</span></span>)</span>
      <span class="fn">⋯</span>)</span></span></div></div><p>Moves an cast using <code><a href=".././Init/Prelude.html#Eq.rec">Eq.rec</a></code> from the function to the argument.
Note: because the motive isn't reliably detected by unification,
it needs to be provided as an explicit parameter.</p></div></div><div class="decl" id="heq_of_eqRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L971-L978">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">h₁</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p>If casting a term with <code><a href=".././Init/Prelude.html#Eq.rec">Eq.rec</a></code> to another type makes it equal to some other term, then the two
terms are heterogeneously equal.</p></div></div><div class="decl" id="cast_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L980-L984">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_heq"><span class="name">cast_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span>)</span> <span class="fn">a</span></span></div></div><p>The result of casting a term with <code><a href=".././Init/Prelude.html#cast">cast</a></code> is heterogeneously equal to the original term.</p></div></div><div class="decl" id="iff_iff_implies_and_implies"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L988-L989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span></div></div></div></div><div class="decl" id="Iff.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L991-L992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Iff.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L994-L995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Iff.of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1000-L1000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Iff.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1002-L1003">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="instTransIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1006-L1007">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instTransIff"><span class="name">instTransIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <a href=".././Init/Core.html#Iff">Iff</a> <a href=".././Init/Core.html#Iff">Iff</a> <a href=".././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instTransIff">instTransIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Eq.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1009-L1009">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.comm"><span class="name">Eq</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="eq_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1010-L1010">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_comm"><span class="name">eq_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="HEq.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1012-L1012">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.comm"><span class="name">HEq</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="heq_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1013-L1013">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_comm"><span class="name">heq_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1015-L1015">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Iff.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1016-L1016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> (<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</div></div></div></div><div class="decl" id="iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1017-L1017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_comm"><span class="name">iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> (<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</div></div></div></div><div class="decl" id="And.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1019-L1019">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.symm"><span class="name">And</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span> → <span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="And.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1020-L1020">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="and_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1021-L1021">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#and_comm"><span class="name">and_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Or.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1023-L1023">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Or.symm"><span class="name">Or</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> → <span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Or.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1024-L1024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Or.comm"><span class="name">Or</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="or_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1025-L1025">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#or_comm"><span class="name">or_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Exists">Exists <a class="hover-link" href="#Exists">#</a></h1></div><div class="decl" id="Exists.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1029-L1032">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Decidable">Decidable <a class="hover-link" href="#Decidable">#</a></h1></div><div class="decl" id="decide_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1036-L1039">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_true"><span class="name">decide_true</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="decide_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1041-L1044">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_false"><span class="name">decide_false</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="decide_true_eq_true"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1047-L1047">source</a></div><div class="attributes">@[reducible, inline, deprecated decide_true (since := &quot;2024-11-05&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#decide_true_eq_true">decide_true_eq_true</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#decide_true">decide_true</a></li></ul></details><details id="instances-for-list-decide_true_eq_true" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decide_false_eq_false"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1049-L1049">source</a></div><div class="attributes">@[reducible, inline, deprecated decide_false (since := &quot;2024-11-05&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#decide_false_eq_false">decide_false_eq_false</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#decide_false">decide_false</a></li></ul></details><details id="instances-for-list-decide_false_eq_false" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="toBoolUsing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1051-L1053">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing"><span class="name">toBoolUsing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Similar to <code>decide</code>, but uses an explicit instance</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span></li></ul></details><details id="instances-for-list-toBoolUsing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="toBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1055-L1056">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="of_toBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1058-L1059">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#of_toBoolUsing_eq_true"><span class="name">of_toBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="of_toBoolUsing_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1061-L1062">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#of_toBoolUsing_eq_false"><span class="name">of_toBoolUsing_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div></div></div><div class="decl" id="ofBoolUsing_eq_true"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1065-L1066">source</a></div><div class="attributes">@[reducible, inline, deprecated of_toBoolUsing_eq_true (since := &quot;2025-04-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href=".././Init/Core.html#ofBoolUsing_eq_true">ofBoolUsing_eq_true</a> <a href=".././Init/Prelude.html#Eq">=</a> @<a href=".././Init/Core.html#of_toBoolUsing_eq_true">of_toBoolUsing_eq_true</a></li></ul></details><details id="instances-for-list-ofBoolUsing_eq_true" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ofBoolUsing_eq_false"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1069-L1070">source</a></div><div class="attributes">@[reducible, inline, deprecated of_toBoolUsing_eq_false (since := &quot;2025-04-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href=".././Init/Core.html#ofBoolUsing_eq_false">ofBoolUsing_eq_false</a> <a href=".././Init/Prelude.html#Eq">=</a> @<a href=".././Init/Core.html#of_toBoolUsing_eq_false">of_toBoolUsing_eq_false</a></li></ul></details><details id="instances-for-list-ofBoolUsing_eq_false" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1072-L1073">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableTrue"><span class="name">instDecidableTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableTrue">instDecidableTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Core.html#trivial">trivial</a></span></li></ul></details></div></div><div class="decl" id="instDecidableFalse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1075-L1076">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableFalse"><span class="name">instDecidableFalse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableFalse">instDecidableFalse</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <a href=".././Init/Core.html#not_false">not_false</a></span></li></ul></details></div></div><div class="decl" id="Decidable.byCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1081-L1090">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dec</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p>Construct a <code>q</code> if some proposition <code>p</code> is decidable, and both the truth and falsity of <code>p</code> are
sufficient to construct a <code>q</code>.</p><p>This is a synonym for <code><a href=".././Init/Prelude.html#dite">dite</a></code>, the dependent if-then-else operator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Decidable.byCases">Decidable.byCases</a> <span class="fn">h1</span> <span class="fn">h2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h1</span> <span class="fn">h</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Core.html#Decidable.byCases">Decidable.byCases</a> <span class="fn">h1</span> <span class="fn">h2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h2</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Decidable.byCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Decidable.em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1092-L1093">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.byContradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1096-L1097">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dec</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1099-L1100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Decidable.not_and_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1102-L1110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d₁</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d₂</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a>(<span class="fn">p</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">q</span>) <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">q</span></div></div></div></div><div class="decl" id="decidable_of_decidable_of_iff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1116-L1121">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equivalence of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-decidable_of_decidable_of_iff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidable_of_decidable_of_eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1123-L1125">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equality of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_eq">decidable_of_decidable_of_eq</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-decidable_of_decidable_of_eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1128-L1132">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableForall"><span class="name">instDecidableForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableForall">instDecidableForall</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1134-L1144">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIff"><span class="name">instDecidableIff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableIff">instDecidableIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span> else <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="if-then-else-expression-theorems">if-then-else expression theorems <a class="hover-link" href="#if-then-else-expression-theorems">#</a></h1></div><div class="decl" id="if_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1148-L1151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_pos"><span class="name">if_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">e</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="if_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1153-L1156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_neg"><span class="name">if_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hnc</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">e</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></div></div></div></div><div class="decl" id="iteInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1158-L1163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iteInduction"><span class="name">iteInduction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">e</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hpos</span> : <span class="fn"><span class="fn">c</span> → <span class="fn"><span class="fn">motive</span> <span class="fn">t</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hneg</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → <span class="fn"><span class="fn">motive</span> <span class="fn">e</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> (<a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span></div></div><p>Split an if-then-else into cases. The <code>split</code> tactic is generally easier to use than this theorem.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#iteInduction">iteInduction</a> <span class="fn">hpos</span> <span class="fn">hneg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hpos</span> <span class="fn">h</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Core.html#iteInduction">iteInduction</a> <span class="fn">hpos</span> <span class="fn">hneg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hneg</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-iteInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="dif_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1165-L1168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_pos"><span class="name">dif_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span> <span class="fn">hc</span></span></div></div></div></div><div class="decl" id="dif_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1170-L1173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_neg"><span class="name">dif_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hnc</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span> <span class="fn">hnc</span></span></div></div></div></div><div class="decl" id="dif_eq_if"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1176-L1179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_eq_if"><span class="name">dif_eq_if</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">e</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(if x : <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span></div></div></div></div><div class="decl" id="instDecidableIte"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1181-L1184">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIte"><span class="name">instDecidableIte</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">t </span><span class="fn">e</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dC</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dT</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">t</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dE</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">e</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableIte">instDecidableIte</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">dT</span></li><li class="equation"><a href=".././Init/Core.html#instDecidableIte">instDecidableIte</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">dE</span></li></ul></details></div></div><div class="decl" id="instDecidableDite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1186-L1189">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableDite"><span class="name">instDecidableDite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">c</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dC</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dT</span> : <span class="fn">(<span class="fn">h</span> : <span class="fn">c</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">t</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dE</span> : <span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">e</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(if h : <span class="fn">c</span> then <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">e</span> <span class="fn">h</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableDite">instDecidableDite</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">dT</span> <span class="fn">h</span></span></li><li class="equation"><a href=".././Init/Core.html#instDecidableDite">instDecidableDite</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">dE</span> <span class="fn">h</span></span></li></ul></details></div></div><div class="decl" id="noConfusionTypeEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1191-L1195">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href=".././foundational_types.html">Sort</a> w)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> w</div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">(<span class="fn">inst</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">y</span>)</span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>) =&gt; <span class="fn">P</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>) =&gt; <span class="fn"><span class="fn">P</span> → <span class="fn">P</span></span></span></span></li></ul></details><details id="instances-for-list-noConfusionTypeEnum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="noConfusionEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1197-L1203">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionEnum"><span class="name">noConfusionEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#noConfusionEnum">noConfusionEnum</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">(<span class="fn">inst</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">y</span>)</span>)</span> <span class="fn">(fun (<span class="fn">h'</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>) =&gt; <span class="fn"><span class="fn">⋯</span>.<a href=".././Init/Prelude.html#False.elim">elim</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>) (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-noConfusionEnum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Inhabited">Inhabited <a class="hover-link" href="#Inhabited">#</a></h1></div><div class="decl" id="instInhabitedProp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1207-L1208">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProp"><span class="name">instInhabitedProp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././foundational_types.html">Prop</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedProp">instInhabitedProp</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedForInStep_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1210-L1210">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a✝</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a✝</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedForInStep_1">instInhabitedForInStep_1</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1210-L1210">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#NonScalar">NonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedNonScalar">instInhabitedNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Core.html#NonScalar.mk">{</a> <span class="fn">val</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Core.html#NonScalar.mk">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedPNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1210-L1210">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#PNonScalar">PNonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedPNonScalar">instInhabitedPNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PNonScalar.mk">PNonScalar.mk</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1210-L1210">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedTrue">instInhabitedTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#True.intro">True.intro</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="nonempty_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1212-L1213">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subsingleton">Subsingleton <a class="hover-link" href="#Subsingleton">#</a></h1></div><div class="decl" id="Subsingleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1217-L1228">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton"><span class="name">Subsingleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A <em>subsingleton</em> is a type with at most one element. It is either empty or has a unique element.</p><p>All propositions are subsingletons because of proof irrelevance: false propositions are empty, and
all proofs of a true proposition are equal to one another. Some non-propositional types are also
subsingletons.</p><ul class="structure_ext"><li id="Subsingleton.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Subsingleton.allEq" class="structure_field"><div class="structure_field_info">allEq<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div><div class="structure_field_doc"><p>Any two elements of a subsingleton are equal.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Subsingleton" class="instances-list"></ul></details></div></div><div class="decl" id="Subsingleton.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1230-L1234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>If a type is a subsingleton, then all of its elements are equal.</p></div></div><div class="decl" id="Subsingleton.helim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1236-L1243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p>If two types are equal and one of them is a subsingleton, then all of their elements are
<a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=HEq">heterogeneously equal</a>.</p></div></div><div class="decl" id="instSubsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1245-L1245">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingleton"><span class="name">instSubsingleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="instSubsingletonEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1247-L1247">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonEmpty"><span class="name">instSubsingletonEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#Empty">Empty</a></span></div></div></div></div><div class="decl" id="instSubsingletonPEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1248-L1248">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonPEmpty"><span class="name">instSubsingletonPEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a></span></div></div></div></div><div class="decl" id="instSubsingletonProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1250-L1251">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonProd"><span class="name">instSubsingletonProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="instSubsingletonDecidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1253-L1260">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span>)</span></span></div></div></div></div><div class="decl" id="recSubsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1265-L1274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#recSubsingleton"><span class="name">recSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><span class="fn">p</span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₂</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h₃</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">h₁</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h₄</span> : <span class="fn">∀ (<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">h₂</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">h₂</span> <span class="fn">h₁</span>)</span></span></div></div></div></div><div class="decl" id="Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1276-L1292">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence"><span class="name">Equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>An equivalence relation <code><a href=".././Init/Core.html#Setoid.r">r</a> : α → α → Prop</code> is a relation that is</p><ul>
<li>reflexive: <code><a href=".././Init/Core.html#Setoid.r">r</a> x x</code>,</li>
<li>symmetric: <code><a href=".././Init/Core.html#Setoid.r">r</a> x y</code> implies <code><a href=".././Init/Core.html#Setoid.r">r</a> y x</code>, and</li>
<li>transitive: <code><a href=".././Init/Core.html#Setoid.r">r</a> x y</code> and <code><a href=".././Init/Core.html#Setoid.r">r</a> y z</code> implies <code><a href=".././Init/Core.html#Setoid.r">r</a> x z</code>.</li>
</ul><p>Equality is an equivalence relation, and equivalence relations share many of the properties of
equality.</p><ul class="structure_fields" id="Equivalence.mk"><li id="Equivalence.refl" class="structure_field"><div class="structure_field_info">refl<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></div><div class="structure_field_doc"><p>An equivalence relation is reflexive: <code><a href=".././Init/Core.html#Setoid.r">r</a> x x</code></p></div></li><li id="Equivalence.symm" class="structure_field"><div class="structure_field_info">symm<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></div><div class="structure_field_doc"><p>An equivalence relation is symmetric: <code><a href=".././Init/Core.html#Setoid.r">r</a> x y</code> implies <code><a href=".././Init/Core.html#Setoid.r">r</a> y x</code></p></div></li><li id="Equivalence.trans" class="structure_field"><div class="structure_field_info">trans<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></div><div class="structure_field_doc"><p>An equivalence relation is transitive: <code><a href=".././Init/Core.html#Setoid.r">r</a> x y</code> and <code><a href=".././Init/Core.html#Setoid.r">r</a> y z</code> implies <code><a href=".././Init/Core.html#Setoid.r">r</a> x z</code></p></div></li></ul><details id="instances-for-list-Equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="emptyRelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1294-L1296">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#emptyRelation"><span class="name">emptyRelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The empty relation is the relation on <code>α</code> which is always <code><a href=".././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#emptyRelation">emptyRelation</a> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></li></ul></details><details id="instances-for-list-emptyRelation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Subrelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1298-L1303">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subrelation"><span class="name">Subrelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q </span><span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Subrelation">Subrelation</a> q <a href=".././Init/Core.html#Setoid.r">r</a></code> means that <code>q ⊆ <a href=".././Init/Core.html#Setoid.r">r</a></code> or <code>∀ x y, q x y → <a href=".././Init/Core.html#Setoid.r">r</a> x y</code>.
It is the analogue of the subset relation on relations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Subrelation">Subrelation</a> <span class="fn">q</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">∀ {<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></li></ul></details><details id="instances-for-list-Subrelation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="InvImage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1305-L1310">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#InvImage"><span class="name">InvImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The inverse image of <code><a href=".././Init/Core.html#Setoid.r">r</a> : β → β → Prop</code> by a function <code>α → β</code> is the relation
<code>s : α → α → Prop</code> defined by <code>s a b = <a href=".././Init/Core.html#Setoid.r">r</a> (f a) (f b)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#InvImage">InvImage</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₂</span>)</span></span></li></ul></details><details id="instances-for-list-InvImage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.TransGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1312-L1322">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Relation.TransGen"><span class="name">Relation</span>.<span class="name">TransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The transitive closure <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> of a relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is the smallest relation which is
transitive and contains <code><a href=".././Init/Core.html#Setoid.r">r</a></code>. <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a z</code> if and only if there exists a sequence
<code>a <a href=".././Init/Core.html#Setoid.r">r</a> b <a href=".././Init/Core.html#Setoid.r">r</a> ... <a href=".././Init/Core.html#Setoid.r">r</a> z</code> of length at least 1 connecting <code>a</code> to <code>z</code>.</p><ul class="constructors"><li class="constructor" id="Relation.TransGen.single">single<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span><div class="inductive_ctor_doc"><p>If <code><a href=".././Init/Core.html#Setoid.r">r</a> a b</code>, then <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a b</code>. This is the base case of the transitive closure.</p></div></li><li class="constructor" id="Relation.TransGen.tail">tail<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span><div class="inductive_ctor_doc"><p>If <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a b</code> and <code><a href=".././Init/Core.html#Setoid.r">r</a> b c</code>, then <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a c</code>.
This is the inductive case of the transitive closure.</p></div></li></ul><details id="instances-for-list-Relation.TransGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.TransGen.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1324-L1330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Relation.TransGen.trans"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></div></div><p>The transitive closure is transitive.</p></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subtype">Subtype <a class="hover-link" href="#Subtype">#</a></h1></div><div class="decl" id="Subtype.exists_of_subtype"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1336-L1337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.exists_of_subtype"><span class="name">Subtype</span>.<span class="name">exists_of_subtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a>), <a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Subtype.existsOfSubtype"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1340-L1341">source</a></div><div class="attributes">@[reducible, inline, deprecated Subtype.exists_of_subtype (since := &quot;2025-04-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a>), <a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href=".././Init/Core.html#Subtype.existsOfSubtype">Subtype.existsOfSubtype</a> <a href=".././Init/Prelude.html#Eq">=</a> @<a href=".././Init/Core.html#Subtype.exists_of_subtype">Subtype.exists_of_subtype</a></li></ul></details><details id="instances-for-list-Subtype.existsOfSubtype" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Subtype.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1345-L1346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a1 </span><span class="fn">a2</span> : <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a1</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a2</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span> → <span class="fn">a1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a2</span></span></div></div></div></div><div class="decl" id="Subtype.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1348-L1350">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span>, <span class="fn">h</span><a href=".././Init/Prelude.html#Subtype.mk">⟩</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Subtype.instBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1352-L1353">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instBEq"><span class="name">Subtype</span>.<span class="name">instBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Subtype.instBEq">Subtype.instBEq</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">y</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></span> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Subtype.instReflBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1355-L1356">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instReflBEq"><span class="name">Subtype</span>.<span class="name">instReflBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#ReflBEq">ReflBEq</a> <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a></span></div></div></div></div><div class="decl" id="Subtype.instLawfulBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1358-L1359">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instLawfulBEq"><span class="name">Subtype</span>.<span class="name">instLawfulBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a></span></div></div></div></div><div class="decl" id="Subtype.instDecidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1361-L1364">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instDecidableEq"><span class="name">Subtype</span>.<span class="name">instDecidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Subtype">}</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">b</span>, <span class="fn">h₂</span><a href=".././Init/Prelude.html#Subtype.mk">⟩</a>.<a href=".././Init/Core.html#Subtype.instDecidableEq">instDecidableEq</a></span> <a href=".././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">b_1</span>, <span class="fn">h₂_1</span><a href=".././Init/Prelude.html#Subtype.mk">⟩</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b_1</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Sum">Sum <a class="hover-link" href="#Sum">#</a></h1></div><div class="decl" id="Sum.inhabitedLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1373-L1375">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div><p>If the left type in a sum is inhabited then the sum is inhabited.</p><p>This is not an instance to avoid non-canonical instances when both the left and right types are
inhabited.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Sum.inhabitedLeft">Sum.inhabitedLeft</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details><details id="instances-for-list-Sum.inhabitedLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sum.inhabitedRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1377-L1379">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div><p>If the right type in a sum is inhabited then the sum is inhabited.</p><p>This is not an instance to avoid non-canonical instances when both the left and right types are
inhabited.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#Sum.inhabitedRight">Sum.inhabitedRight</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details><details id="instances-for-list-Sum.inhabitedRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sum.nonemptyLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1381-L1382">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.nonemptyLeft"><span class="name">Sum</span>.<span class="name">nonemptyLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="Sum.nonemptyRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1384-L1385">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.nonemptyRight"><span class="name">Sum</span>.<span class="name">nonemptyRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="instDecidableEqSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1387-L1396">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqSum">instDecidableEqSum</a> <span class="fn">(<a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">a_2</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">b_2</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">a_2</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b_2</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqSum">instDecidableEqSum</a> <span class="fn">(<a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">a_2</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">b_2</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">a_2</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b_2</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqSum">instDecidableEqSum</a> <span class="fn">(<a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">val</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">val_1</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqSum">instDecidableEqSum</a> <span class="fn">(<a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">val</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">val_1</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Product">Product <a class="hover-link" href="#Product">#</a></h1></div><div class="decl" id="instNonemptyProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1402-L1405">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyProd"><span class="name">instNonemptyProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h1</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h2</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="instNonemptyMProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1407-L1410">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyMProd"><span class="name">instNonemptyMProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h1</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h2</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href=".././Init/Prelude.html#MProd">MProd</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="instNonemptyPProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1412-L1415">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyPProd"><span class="name">instNonemptyPProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h1</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h2</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#PProd">×'</a> <span class="fn">β</span>)</span></div></div></div></div><div class="decl" id="instInhabitedProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1417-L1418">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProd"><span class="name">instInhabitedProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedProd">instInhabitedProd</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Prod.mk">(</a><a href=".././Init/Prelude.html#Inhabited.default">default</a><a href=".././Init/Prelude.html#Prod.mk">,</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a><a href=".././Init/Prelude.html#Prod.mk">)</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedMProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1420-L1421">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#MProd">MProd</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedMProd">instInhabitedMProd</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">⟨<a href=".././Init/Prelude.html#Inhabited.default">default</a>, <a href=".././Init/Prelude.html#Inhabited.default">default</a>⟩</span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedPProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1423-L1424">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#PProd">×'</a> <span class="fn">β</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedPProd">instInhabitedPProd</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">⟨<a href=".././Init/Prelude.html#Inhabited.default">default</a>, <a href=".././Init/Prelude.html#Inhabited.default">default</a>⟩</span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instDecidableEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1426-L1433">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instBEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1435-L1436">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instBEqProd"><span class="name">instBEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> (<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instBEqProd">instBEqProd</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#BEq.mk">{</a>     <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn">b₁</span><a href=".././Init/Prelude.html#Prod.mk">)</a> =&gt;
        <span class="fn">match <span class="fn">x_1</span> with
        | <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">a₂</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn">b₂</span><a href=".././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn">a₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span></span></span></span> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Prod.lexLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1438-L1445">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s </span><span class="fn">t</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Lexicographical order for products.</p><p>Two pairs are lexicographically ordered if their first elements are ordered or if their first
elements are equal and their second elements are ordered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Core.html#Prod.lexLt">lexLt</a></span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span>)</li></ul></details><details id="instances-for-list-Prod.lexLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Prod.lexLtDec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1447-L1451">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s </span><span class="fn">t</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">s</span>.<a href=".././Init/Core.html#Prod.lexLt">lexLt</a></span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href=".././Init/Core.html#Prod.lexLtDec">lexLtDec</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">x✝¹</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x✝¹</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x✝¹</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="Prod.lexLt_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1453-L1454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s </span><span class="fn">t</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Core.html#Prod.lexLt">lexLt</a></span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span>)</div></div></div></div><div class="decl" id="Prod.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1456-L1456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span><a href=".././Init/Prelude.html#Prod.mk">)</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="Prod.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1458-L1467">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α₁</span> : <a href=".././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α₂</span> : <a href=".././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β₁</span> : <a href=".././foundational_types.html">Type</a> v₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β₂</span> : <a href=".././foundational_types.html">Type</a> v₂}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α₁</span> → <span class="fn">α₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">β₁</span> → <span class="fn">β₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α₁</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₁</span> → <span class="fn">α₂</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₂</span></span></div></div><p>Transforms a pair by applying functions to both elements.</p><p>Examples:</p><ul>
<li><code>(1, 2).<a href=".././Init/Core.html#Thunk.map">map</a> (· + 1) (· * 3) = (2, 6)</code></li>
<li><code>(1, 2).<a href=".././Init/Core.html#Thunk.map">map</a> toString (· * 3) = (&quot;1&quot;, 6)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">a'</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn">b'</span><a href=".././Init/Prelude.html#Prod.mk">)</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">g</span> <span class="fn">b'</span></span><a href=".././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Prod.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Prod.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1469-L1470">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_apply"><span class="name">Prod</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Prod.map">map</a> <span class="fn">f</span> <span class="fn">g</span> <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href=".././Init/Prelude.html#Prod.mk">)</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span><a href=".././Init/Prelude.html#Prod.mk">)</a></div></div></div></div><div class="decl" id="Prod.map_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1471-L1471">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_fst"><span class="name">Prod</span>.<span class="name">map_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Core.html#Prod.map">map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span>)</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Prod.fst">fst</a></span></span></div></div></div></div><div class="decl" id="Prod.map_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1472-L1472">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_snd"><span class="name">Prod</span>.<span class="name">map_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Core.html#Prod.map">map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span>)</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Prod.snd">snd</a></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Dependent-products">Dependent products <a class="hover-link" href="#Dependent-products">#</a></h1></div><div class="decl" id="Exists.of_psigma_prop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1476-L1477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists.of_psigma_prop"><span class="name">Exists</span>.<span class="name">of_psigma_prop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) ×' <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>), <a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="PSigma.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1479-L1483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₂</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">h₁</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn">b₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#PSigma.mk">⟨</a><span class="fn">a₁</span>, <span class="fn">b₁</span><a href=".././Init/Core.html#PSigma.mk">⟩</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#PSigma.mk">⟨</a><span class="fn">a₂</span>, <span class="fn">b₂</span><a href=".././Init/Core.html#PSigma.mk">⟩</a></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Universe-polymorphic-unit">Universe polymorphic unit <a class="hover-link" href="#Universe-polymorphic-unit">#</a></h1></div><div class="decl" id="PUnit.subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1487-L1488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="PUnit.eq_punit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1490-L1491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">unit</a></div></div></div></div><div class="decl" id="instSubsingletonPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1493-L1494">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div></div></div><div class="decl" id="instInhabitedPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1496-L1497">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instInhabitedPUnit">instInhabitedPUnit</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instDecidableEqPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1499-L1500">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableEqPUnit">instDecidableEqPUnit</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Setoid">Setoid <a class="hover-link" href="#Setoid">#</a></h1></div><div class="decl" id="Setoid"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1504-L1513">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid"><span class="name">Setoid</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>A setoid is a type with a distinguished equivalence relation, denoted <code>≈</code>.</p><p>The <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> type constructor requires a <code><a href=".././Init/Core.html#Setoid">Setoid</a></code> instance.</p><ul class="structure_fields" id="Setoid.mk"><li id="Setoid.r" class="structure_field"><div class="structure_field_info">r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p><code>x ≈ y</code> is the distinguished equivalence relation of a setoid.</p></div></li><li id="Setoid.iseqv" class="structure_field"><div class="structure_field_info">iseqv : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <a href=".././Init/Core.html#Setoid.r">r</a></span></div><div class="structure_field_doc"><p>The relation <code>x ≈ y</code> is an equivalence relation.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Setoid" class="instances-list"></ul></details></div></div><div class="decl" id="instHasEquivOfSetoid"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1515-L1516">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instHasEquivOfSetoid"><span class="name">instHasEquivOfSetoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instHasEquivOfSetoid">instHasEquivOfSetoid</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#HasEquiv.mk">{</a> <span class="fn">Equiv</span> := <a href=".././Init/Core.html#Setoid.r">Setoid.r</a> <a href=".././Init/Core.html#HasEquiv.mk">}</a></li></ul></details></div></div><div class="decl" id="Setoid.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1522-L1524">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></div></div><p>A setoid's equivalence relation is reflexive.</p></div></div><div class="decl" id="Setoid.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1526-L1528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></div></div><p>A setoid's equivalence relation is symmetric.</p></div></div><div class="decl" id="Setoid.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1530-L1532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span></div></div><p>A setoid's equivalence relation is transitive.</p></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Propositional-extensionality">Propositional extensionality <a class="hover-link" href="#Propositional-extensionality">#</a></h1></div><div class="decl" id="propext"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1539-L1573">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#propext"><span class="name">propext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) → <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href=".././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

def foo : <a href=".././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href=".././Init/Prelude.html#True">True</a> := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩
  have := <a href=".././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  <a href=".././Init/Core.html#Quotient.exact">exact</a> this

#reduce foo
-- <a href=".././Init/Core.html#propext">propext</a> { <a href=".././Init/Core.html#Iff.mp">mp</a> := fun x x =&gt; True.intro, <a href=".././Init/Core.html#Iff.mpr">mpr</a> := fun x =&gt; <a href=".././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href=".././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p></div></div><div class="decl" id="Eq.propIntro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1575-L1576">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="instDecidableEqOfIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1579-L1582">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqOfIff"><span class="name">instDecidableEqOfIff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Core.html#instDecidableEqOfIff">instDecidableEqOfIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Core.html#instDecidableEqOfIff">instDecidableEqOfIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Nat.succ.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1622-L1623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.succ.inj"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> → <span class="fn">m</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.succ.injEq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1625-L1626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.succ.injEq"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">injEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">u </span><span class="fn">v</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">u</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">v</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">u</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">v</span>)</div></div></div></div><div class="decl" id="beq_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1628-L1629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_iff_eq"><span class="name">beq_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Prop-lemmas">Prop lemmas <a class="hover-link" href="#Prop-lemmas">#</a></h1></div><div class="decl" id="Not.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1633-L1635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.elim"><span class="name">Not</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H1</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H2</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><em>Ex falso</em> for negation: from <code>¬a</code> and <code>a</code> anything follows. This is the same as <code><a href=".././Init/Prelude.html#absurd">absurd</a></code> with
the arguments flipped, but it is in the <code><a href=".././Init/Prelude.html#Not">Not</a></code> namespace so that projection notation can be used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H1</span>.<a href=".././Init/Core.html#Not.elim">elim</a></span> <span class="fn">H2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#absurd">absurd</a> <span class="fn">H2</span> <span class="fn">H1</span></span></li></ul></details><details id="instances-for-list-Not.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="And.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1637-L1638">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.elim"><span class="name">And</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Non-dependent eliminator for <code><a href=".././Init/Prelude.html#And">And</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#And.elim">And.elim</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-And.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Iff.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1640-L1641">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.elim"><span class="name">Iff</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Non-dependent eliminator for <code><a href=".././Init/Core.html#Iff">Iff</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Iff.elim">Iff.elim</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Iff.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Iff.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1643-L1645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href=".././foundational_types.html">Prop</a> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div><p>Iff can now be used to do substitutions in a calculation</p></div></div><div class="decl" id="Not.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1647-L1647">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.intro"><span class="name">Not</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="Not.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1649-L1649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.imp"><span class="name">Not</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H2</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H1</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="not_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1651-L1651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_congr"><span class="name">not_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="not_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1653-L1653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_not"><span class="name">not_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="iff_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1655-L1655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_true"><span class="name">iff_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="iff_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1656-L1656">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_false"><span class="name">iff_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="iff_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1658-L1658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_left"><span class="name">iff_true_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="iff_true_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1659-L1659">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_right"><span class="name">iff_true_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="iff_false_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1661-L1661">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_left"><span class="name">iff_false_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="iff_false_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1662-L1662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_right"><span class="name">iff_false_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>) <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="of_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1664-L1664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#of_iff_true"><span class="name">of_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div></div></div><div class="decl" id="iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1665-L1665">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_intro"><span class="name">iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="eq_iff_true_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1667-L1668">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_iff_true_of_subsingleton"><span class="name">eq_iff_true_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="not_of_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1670-L1670">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_of_iff_false"><span class="name">not_of_iff_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a>) → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></div></div></div></div><div class="decl" id="iff_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1671-L1671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_intro"><span class="name">iff_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="not_iff_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1673-L1673">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_iff_false_intro"><span class="name">not_iff_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="not_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1674-L1674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_true"><span class="name">not_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="not_false_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1676-L1676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_false_iff"><span class="name">not_false_iff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="Eq.to_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1678-L1678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.to_iff"><span class="name">Eq</span>.<span class="name">to_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → (<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></div></div></div></div><div class="decl" id="iff_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1679-L1679">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_eq"><span class="name">iff_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → (<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></div></div></div></div><div class="decl" id="neq_of_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1680-L1680">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#neq_of_not_iff"><span class="name">neq_of_not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) → <span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="iff_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1682-L1682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_iff_eq"><span class="name">iff_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="eq_iff_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1683-L1683">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_iff_iff"><span class="name">eq_iff_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="eq_self_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1685-L1685">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_self_iff_true"><span class="name">eq_self_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="ne_self_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1686-L1686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_self_iff_false"><span class="name">ne_self_iff_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="false_of_true_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1688-L1688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_true_iff_false"><span class="name">false_of_true_iff_false</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="false_of_true_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1689-L1689">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_true_eq_false"><span class="name">false_of_true_eq_false</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="true_eq_false_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1691-L1691">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_eq_false_of_false"><span class="name">true_eq_false_of_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#False">False</a> → <a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="iff_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1693-L1693">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_def"><span class="name">iff_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span></div></div></div></div><div class="decl" id="iff_def'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1694-L1694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_def'"><span class="name">iff_def'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></div></div></div></div><div class="decl" id="true_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1696-L1696">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_iff_false"><span class="name">true_iff_false</span></a></span><span class="decl_args"> :</span><div class="decl_type">(<a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a>) <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="false_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1697-L1697">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_iff_true"><span class="name">false_iff_true</span></a></span><span class="decl_args"> :</span><div class="decl_type">(<a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a>) <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="iff_not_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1699-L1699">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_not_self"><span class="name">iff_not_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</div></div></div></div><div class="decl" id="heq_self_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1700-L1700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_self_iff_true"><span class="name">heq_self_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="mod_doc"><h2 class="markdown-heading" id="implies">implies <a class="hover-link" href="#implies">#</a></h2></div><div class="decl" id="not_not_of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1704-L1704">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_of_not_imp"><span class="name">not_not_of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1706-L1706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_of_not_imp"><span class="name">not_of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></div></div></div></div><div class="decl" id="imp_not_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1708-L1708">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_not_self"><span class="name">imp_not_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="imp_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1710-L1710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_intro"><span class="name">imp_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></div></div></div></div><div class="decl" id="imp_imp_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1712-L1712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_imp_imp"><span class="name">imp_imp_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₀</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="imp_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1714-L1714">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_iff_right"><span class="name">imp_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="imp_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1717-L1717">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_true_iff"><span class="name">imp_true_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href=".././Init/Prelude.html#True">True</a>)</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="false_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1719-L1719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_imp_iff"><span class="name">false_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#False">False</a> → <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="true_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1721-L1721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_imp_iff"><span class="name">true_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#True">True</a> → <span class="fn">α</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">α</span></div></div></div></div><div class="decl" id="imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1723-L1723">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_self"><span class="name">imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="imp_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1725-L1725">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_false"><span class="name">imp_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1727-L1727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp.swap"><span class="name">imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="imp_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1729-L1729">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_not_comm"><span class="name">imp_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="imp_congr_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1731-L1731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_left"><span class="name">imp_congr_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></div></div></div></div><div class="decl" id="imp_congr_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1733-L1734">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_right"><span class="name">imp_congr_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> → (<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></div></div></div></div><div class="decl" id="imp_congr_ctx"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1736-L1737">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_ctx"><span class="name">imp_congr_ctx</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">c</span> → (<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></div></div></div></div><div class="decl" id="imp_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1739-L1739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr"><span class="name">imp_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></div></div></div></div><div class="decl" id="imp_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1741-L1741">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_iff_not"><span class="name">imp_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Quotients">Quotients <a class="hover-link" href="#Quotients">#</a></h1></div><div class="decl" id="Quot.sound"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1746-L1763">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span></div></div><p>The <strong>quotient axiom</strong>, which asserts the equality of elements related by the quotient's relation.</p><p>The relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> does not need to be an equivalence relation to use this axiom. When <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is not an
equivalence relation, the quotient is with respect to the equivalence relation generated by <code><a href=".././Init/Core.html#Setoid.r">r</a></code>.</p><p><code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> is part of the built-in primitive quotient type:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a></code> is the built-in quotient type.</li>
<li><code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> places elements of the underlying type <code>α</code> into the quotient.</li>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> allows the definition of functions from the quotient to some other type.</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is used to write proofs about quotients by assuming that all elements are constructed
with <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code>; it is analogous to the <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a
structure.</li>
</ul><p><a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=quotients">Quotient types</a> are described in more detail in the Lean Language
Reference.</p></div></div><div class="decl" id="Quot.liftBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1765-L1770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Quot.lift">lift</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Quot.indBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1772-L1776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="Quot.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1778-L1793">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Lifts a function from an underlying type to a function on a quotient, requiring that it respects the
quotient's relation.</p><p>Given a relation <code><a href=".././Init/Core.html#Setoid.r">r</a> : α → α → Prop</code> and a quotient's value <code>q : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a></code>, applying a <code>f : α → β</code>
requires a proof <code>c</code> that <code>f</code> respects <code><a href=".././Init/Core.html#Setoid.r">r</a></code>. In this case, <code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> q f h : β</code> evaluates
to the result of applying <code>f</code> to the underlying value in <code>α</code> from <code>q</code>.</p><p><code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a></code> is a version of the built-in primitive <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> with its parameters re-ordered.</p><p><a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=quotients">Quotient types</a> are described in more detail in the Lean Language
Reference.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q</span>.<a href=".././Init/Core.html#Quot.liftOn">liftOn</a></span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q</span></span></li></ul></details><details id="instances-for-list-Quot.liftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1795-L1800">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Quot.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1802-L1803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Quot.indep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1810-L1813">source</a></div><div class="attributes">@[reducible, macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#PSigma">PSigma</a> <span class="fn">motive</span></span></div></div><p>Auxiliary definition for <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#PSigma.mk">⟨</a><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span><a href=".././Init/Core.html#PSigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Quot.indep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.indepCoherent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1815-L1819">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Quot.liftIndepPr1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1821-L1827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Quot.lift">lift</a> <span class="fn">(<a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span>)</span> <span class="fn">⋯</span> <span class="fn">q</span>)</span>.<a href=".././Init/Core.html#PSigma.fst">fst</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Quot.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1829-L1848">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>. It is analogous to the
<a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a structure, and can be used when the resulting type
is not necessarily a proposition.</p><p>While it is very general, this recursor can be tricky to use. The following simpler alternatives may
be easier to use:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> is useful for defining non-dependent functions.</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is useful for proving theorems about quotients.</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code> can be used whenever the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.</li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code> uses <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=HEq">heterogeneous equality</a> instead of rewriting with
<code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code>.</li>
</ul><p><code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code> is a version of this recursor that takes the quotient parameter first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Eq.ndrecOn">Eq.ndrecOn</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">(<a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span>)</span> <span class="fn">⋯</span> <span class="fn">q</span>)</span>.<a href=".././Init/Core.html#PSigma.snd">snd</a></span></span></li></ul></details><details id="instances-for-list-Quot.rec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1850-L1870">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code> that takes the quotient first. It is analogous to the
<a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a structure, and can be used when the resulting type
is not necessarily a proposition.</p><p>While it is very general, this recursor can be tricky to use. The following simpler alternatives may
be easier to use:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> is useful for defining non-dependent functions.</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is useful for proving theorems about quotients.</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code> can be used whenever the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.</li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code> uses <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=HEq">heterogeneous equality</a> instead of rewriting with
<code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code>.</li>
</ul><p><code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code> is a version of this recursor that takes the quotient parameter last.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></li></ul></details><details id="instances-for-list-Quot.recOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1872-L1888">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>An alternative induction principle for quotients that can be used when the target type is a
subsingleton, in which all elements are equal.</p><p>In these cases, the proof that the function respects the quotient's relation is trivial, so any
function can be lifted.</p><p><code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code> does not assume that the type is a subsingleton.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span> <span class="fn">⋯</span> <span class="fn">q</span></span></li></ul></details><details id="instances-for-list-Quot.recOnSubsingleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1890-L1902">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code> that uses <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=HEq">heterogeneous
equality</a>, analogous to a <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for
a structure.</p><p><code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code> is a version of this recursor that uses <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> instead of <code><a href=".././Init/Prelude.html#HEq">HEq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Quot.hrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1908-L1930">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient"><span class="name">Quotient</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Quotient types coarsen the propositional equality for a type so that terms related by some
equivalence relation are considered equal. The equivalence relation is given by an instance of
<code><a href=".././Init/Core.html#Setoid">Setoid</a></code>.</p><p>Set-theoretically, <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> can seen as the set of equivalence classes of <code>α</code> modulo the
<code><a href=".././Init/Core.html#Setoid">Setoid</a></code> instance's relation <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>. Functions from <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> must prove that they respect <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>:
to define a function <code>f : <a href=".././Init/Core.html#Quotient">Quotient</a> s → β</code>, it is necessary to provide <code>f' : α → β</code> and prove that
for all <code>x : α</code> and <code>y : α</code>, <code>s.<a href=".././Init/Core.html#Setoid.r">r</a> x y → f' x = f' y</code>. <code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> implements this operation.</p><p>The key quotient operators are:</p><ul>
<li><code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a></code> places elements of the underlying type <code>α</code> into the quotient.</li>
<li><code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> allows the definition of functions from the quotient to some other type.</li>
<li><code><a href=".././Init/Core.html#Quotient.sound">Quotient.sound</a></code> asserts the equality of elements related by <code><a href=".././Init/Core.html#Setoid.r">r</a></code></li>
<li><code><a href=".././Init/Core.html#Quotient.ind">Quotient.ind</a></code> is used to write proofs about quotients by assuming that all elements are
constructed with <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a></code>.</li>
</ul><p><code><a href=".././Init/Core.html#Quotient">Quotient</a></code> is built on top of the primitive quotient type <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>, which does not require a proof
that the relation is an equivalence relation. <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> should be used instead of <code><a href=".././Init/Prelude.html#Quot">Quot</a></code> for
relations that actually are equivalence relations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">Setoid.r</a></span></li></ul></details><details id="instances-for-list-Quotient" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1934-L1946">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>Places an element of a type into the quotient that equates terms according to an equivalence
relation.</p><p>The setoid instance is provided explicitly. <code><a href=".././Init/Core.html#Quotient.mk'">Quotient.mk'</a></code> uses instance synthesis instead.</p><p>Given <code>v : α</code>, <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s v : <a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is like <code>v</code>, except all observations of <code>v</code>'s value
must respect <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>. <code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> allows values in a quotient to be mapped to other types, so long
as the mapping respects <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <a href=".././Init/Core.html#Setoid.r">Setoid.r</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-Quotient.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1948-L1961">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>Places an element of a type into the quotient that equates terms according to an equivalence
relation.</p><p>The equivalence relation is found by synthesizing a <code><a href=".././Init/Core.html#Setoid">Setoid</a></code> instance. <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a></code> instead expects
the instance to be provided explicitly.</p><p>Given <code>v : α</code>, <code><a href=".././Init/Core.html#Quotient.mk'">Quotient.mk'</a> v : <a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is like <code>v</code>, except all observations of <code>v</code>'s value
must respect <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>. <code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> allows values in a quotient to be mapped to other types, so long
as the mapping respects <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.mk'">Quotient.mk'</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-Quotient.mk'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.sound"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1963-L1971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span> → <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span></div></div><p>The <strong>quotient axiom</strong>, which asserts the equality of elements related in the setoid.</p><p>Because <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> is built on a lower-level type <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>, <code><a href=".././Init/Core.html#Quotient.sound">Quotient.sound</a></code> is implemented as a
theorem. It is derived from <code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code>, the soundness axiom for the lower-level quotient type
<code><a href=".././Init/Prelude.html#Quot">Quot</a></code>.</p></div></div><div class="decl" id="Quotient.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1973-L1985">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <span class="fn">β</span></span></span></div></div><p>Lifts a function from an underlying type to a function on a quotient, requiring that it respects the
quotient's equivalence relation.</p><p>Given <code>s : <a href=".././Init/Core.html#Setoid">Setoid</a> α</code> and a quotient <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code>, applying a function <code>f : α → β</code> requires a proof
<code>h</code> that <code>f</code> respects the equivalence relation <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>. In this case, the function
<code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> f h : <a href=".././Init/Core.html#Quotient">Quotient</a> s → β</code> computes the same values as <code>f</code>.</p><p><code><a href=".././Init/Core.html#Quotient.liftOn">Quotient.liftOn</a></code> is a version of this operation that takes the quotient value as its first explicit
parameter.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span></span></li></ul></details><details id="instances-for-list-Quotient.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1987-L1992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span>)</span> → <span class="fn">∀ (<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>), <span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></span></span></div></div><p>A reasoning principle for quotients that allows proofs about quotients to assume that all values are
constructed with <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a></code>.</p></div></div><div class="decl" id="Quotient.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L1994-L2006">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Lifts a function from an underlying type to a function on a quotient, requiring that it respects the
quotient's equivalence relation.</p><p>Given <code>s : <a href=".././Init/Core.html#Setoid">Setoid</a> α</code> and a quotient value <code>q : <a href=".././Init/Core.html#Quotient">Quotient</a> s</code>, applying a function <code>f : α → β</code> requires
a proof <code>c</code> that <code>f</code> respects the equivalence relation <code>s.<a href=".././Init/Core.html#Setoid.r">r</a></code>. In this case, the term
<code><a href=".././Init/Core.html#Quotient.liftOn">Quotient.liftOn</a> q f h : β</code> reduces to the result of applying <code>f</code> to the underlying <code>α</code> value.</p><p><code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> is a version of this operation that takes the quotient value last, rather than
first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q</span>.<a href=".././Init/Core.html#Quotient.liftOn">liftOn</a></span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></li></ul></details><details id="instances-for-list-Quotient.liftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2008-L2014">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.inductionOn">Quot.inductionOn</a></code>: every element of <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is of the form <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p></div></div><div class="decl" id="Quotient.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2016-L2017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Exists">∃</a> <a href=".././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href=".././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href=".././Init/Core.html#Exists">)</a><a href=".././Init/Core.html#Exists">,</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Quotient.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2024-L2045">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. It is analogous to the
<a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a structure, and can be used when the resulting type
is not necessarily a proposition.</p><p>While it is very general, this recursor can be tricky to use. The following simpler alternatives may
be easier to use:</p><ul>
<li><code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> is useful for defining non-dependent functions.</li>
<li><code><a href=".././Init/Core.html#Quotient.ind">Quotient.ind</a></code> is useful for proving theorems about quotients.</li>
<li><code><a href=".././Init/Core.html#Quotient.recOnSubsingleton">Quotient.recOnSubsingleton</a></code> can be used whenever the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.</li>
<li><code><a href=".././Init/Core.html#Quotient.hrecOn">Quotient.hrecOn</a></code> uses heterogeneous equality instead of rewriting with <code><a href=".././Init/Core.html#Quotient.sound">Quotient.sound</a></code>.</li>
</ul><p><code><a href=".././Init/Core.html#Quotient.recOn">Quotient.recOn</a></code> is a version of this recursor that takes the quotient parameter first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.rec">Quotient.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></li></ul></details><details id="instances-for-list-Quotient.rec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2047-L2068">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>), <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.ndrec">▸</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. It is analogous to the
<a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a structure, and can be used when the resulting type
is not necessarily a proposition.</p><p>While it is very general, this recursor can be tricky to use. The following simpler alternatives may
be easier to use:</p><ul>
<li><code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> is useful for defining non-dependent functions.</li>
<li><code><a href=".././Init/Core.html#Quotient.ind">Quotient.ind</a></code> is useful for proving theorems about quotients.</li>
<li><code><a href=".././Init/Core.html#Quotient.recOnSubsingleton">Quotient.recOnSubsingleton</a></code> can be used whenever the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.</li>
<li><code><a href=".././Init/Core.html#Quotient.hrecOn">Quotient.hrecOn</a></code> uses heterogeneous equality instead of rewriting with <code><a href=".././Init/Core.html#Quotient.sound">Quotient.sound</a></code>.</li>
</ul><p><code><a href=".././Init/Core.html#Quotient.rec">Quotient.rec</a></code> is a version of this recursor that takes the quotient parameter last.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.recOn">Quotient.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Quotient.recOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2070-L2085">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>An alternative recursion or induction principle for quotients that can be used when the target type
is a subsingleton, in which all elements are equal.</p><p>In these cases, the proof that the function respects the quotient's equivalence relation is trivial,
so any function can be lifted.</p><p><code><a href=".././Init/Core.html#Quotient.rec">Quotient.rec</a></code> does not assume that the target type is a subsingleton.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton">Quotient.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span></li></ul></details><details id="instances-for-list-Quotient.recOnSubsingleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2087-L2100">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A dependent recursion principle for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> that uses <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=HEq">heterogeneous
equality</a>, analogous to a <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for
a structure.</p><p><code><a href=".././Init/Core.html#Quotient.recOn">Quotient.recOn</a></code> is a version of this recursor that uses <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> instead of <code><a href=".././Init/Prelude.html#HEq">HEq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.hrecOn">Quotient.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></li></ul></details><details id="instances-for-list-Quotient.hrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.lift₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2108-L2123">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span> → <span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lifts a binary function from the underlying types to a binary function on quotients. The function
must respect both quotients' equivalence relations.</p><p><code><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a></code> is a version of this operation for unary functions. <code><a href=".././Init/Core.html#Quotient.liftOn₂">Quotient.liftOn₂</a></code> is a version
that take the quotient parameters first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">(fun (<span class="fn">a₁</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">⋯</span> <span class="fn">q₂</span></span>)</span> <span class="fn">⋯</span> <span class="fn">q₁</span></span></li></ul></details><details id="instances-for-list-Quotient.lift₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.liftOn₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2125-L2138">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span> → <span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lifts a binary function from the underlying types to a binary function on quotients. The function
must respect both quotients' equivalence relations.</p><p><code><a href=".././Init/Core.html#Quotient.liftOn">Quotient.liftOn</a></code> is a version of this operation for unary functions. <code><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a></code> is a version
that take the quotient parameters last.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q₁</span>.<a href=".././Init/Core.html#Quotient.liftOn₂">liftOn₂</a></span> <span class="fn">q₂</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></li></ul></details><details id="instances-for-list-Quotient.liftOn₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.ind₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2140-L2149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2151-L2160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2162-L2174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₃</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">φ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span> → <a href=".././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₃</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>) (<span class="fn">c</span> : <span class="fn">φ</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₃</span> <span class="fn">c</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">q₃</span></span></div></div></div></div><div class="decl" id="Quotient.exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2196-L2200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span></div></div><p>If two values are equal in a quotient, then they are related by its equivalence relation.</p></div></div><div class="decl" id="Quotient.recOnSubsingleton₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2209-L2230">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₂</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Sort</a> uC</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">s</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q₁</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q₂</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div><p>An alternative induction or recursion operator for defining binary operations on quotients that can
be used when the target type is a subsingleton.</p><p>In these cases, the proof that the function respects the quotient's equivalence relation is trivial,
so any function can be lifted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">g</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₁</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₂</span> <span class="fn">fun (<span class="fn">a_1</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">a</span> <span class="fn">a_1</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Quotient.recOnSubsingleton₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.decidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2235-L2242">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.decidableEq"><span class="name">Quotient</span>.<span class="name">decidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d</span> : <span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q₁</span>.<a href=".././Init/Core.html#Quotient.decidableEq">decidableEq</a></span> <span class="fn">q₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">fun (<span class="fn">a₁</span> <span class="fn">a₂</span> : <span class="fn">α</span>) =&gt;
    <span class="fn">match <span class="fn"><span class="fn">d</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> with
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h₁</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h₂</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Function-extensionality">Function extensionality <a class="hover-link" href="#Function-extensionality">#</a></h1></div><div class="decl" id="funext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2246-L2263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#funext"><span class="name">funext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div><p><strong>Function extensionality.</strong> If two functions return equal results for all possible arguments, then
they are equal.</p><p>It is called “extensionality” because it provides a way to prove two objects equal based on the
properties of the underlying mathematical functions, rather than based on the syntax used to denote
them. Function extensionality is a theorem that can be <a href="https://lean-lang.org/doc/reference/4.20.0-rc5/find/?domain=Verso.Genre.Manual.section&amp;name=quotient-funext">proved using quotient
types</a>.</p></div></div><div class="decl" id="Quot.pliftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2265-L2275">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.pliftOn"><span class="name">Quot</span>.<span class="name">pliftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span>) (<span class="fn">h'</span> : <span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">h'</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Like <code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> q f h</code> but allows <code>f a</code> to &quot;know&quot; that <code>q = <a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <a href=".././Init/Core.html#Setoid.r">r</a> a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q</span>.<a href=".././Init/Core.html#Quot.pliftOn">pliftOn</a></span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> (motive := <span class="fn">fun (<span class="fn">q'</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>) =&gt; <span class="fn"><span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q'</span> → <span class="fn">β</span></span></span>) <span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">q</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Quot.pliftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.pliftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2277-L2284">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.pliftOn"><span class="name">Quotient</span>.<span class="name">pliftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>) (<span class="fn">h'</span> : <span class="fn">q</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">h'</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Like <code><a href=".././Init/Core.html#Quotient.liftOn">Quotient.liftOn</a> q f h</code> but allows <code>f a</code> to &quot;know&quot; that <code>q = <a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">q</span>.<a href=".././Init/Core.html#Quotient.pliftOn">pliftOn</a></span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.pliftOn">Quot.pliftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Quotient.pliftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Pi.instSubsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2286-L2288">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Pi.instSubsingleton"><span class="name">Pi</span>.<span class="name">instSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Squash">Squash <a class="hover-link" href="#Squash">#</a></h1></div><div class="decl" id="Squash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2292-L2306">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash"><span class="name">Squash</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>The quotient of <code>α</code> by the universal relation. The elements of <code><a href=".././Init/Core.html#Squash">Squash</a> α</code> are those of <code>α</code>, but all
of them are equal and cannot be distinguished.</p><p><code><a href=".././Init/Core.html#Squash">Squash</a> α</code> is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>: it is empty if <code>α</code> is empty, otherwise it has just one element. It
is the “universal <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>” mapped from <code>α</code>.</p><p><code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> also has these properties. It is a proposition, which means that its elements (i.e.
proofs) are erased from compiled code and represented by a dummy value. <code><a href=".././Init/Core.html#Squash">Squash</a> α</code> is a <code>Type u</code>,
and its representation in compiled code is identical to that of <code>α</code>.</p><p>Consequently, <code><a href=".././Init/Core.html#Squash.lift">Squash.lift</a></code> may extract an <code>α</code> value into any subsingleton type <code>β</code>, while
<code><a href=".././Init/Prelude.html#Nonempty.rec">Nonempty.rec</a></code> can only do the same when <code>β</code> is a proposition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#True">True</a></span></span></li></ul></details><details id="instances-for-list-Squash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Squash.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2308-L2311">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span></div></div><p>Places a value into its squash type, in which it cannot be distinguished from any other.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Squash.mk">Squash.mk</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#True">True</a>)</span> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Squash.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Squash.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2313-L2318">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Squash.mk">mk</a> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>A reasoning principle that allows proofs about squashed types to assume that all values are
constructed with <code><a href=".././Init/Core.html#Squash.mk">Squash.mk</a></code>.</p></div></div><div class="decl" id="Squash.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2320-L2327">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Extracts a squashed value into any subsingleton type.</p><p>If <code>β</code> is a subsingleton, a function <code>α → β</code> cannot distinguish between elements of <code>α</code> and thus
automatically respects the universal relation that <code><a href=".././Init/Core.html#Squash">Squash</a></code> quotients with.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Core.html#Squash.lift">lift</a></span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-Squash.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instSubsingletonSquash"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2329-L2334">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span>)</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Kernel-reduction-hints">Kernel reduction hints <a class="hover-link" href="#Kernel-reduction-hints">#</a></h1></div><div class="decl" id="Lean.trustCompiler"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2339-L2342">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.trustCompiler"><span class="name">Lean</span>.<span class="name">trustCompiler</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#True">True</a></div></div><p>Depends on the correctness of the Lean compiler, interpreter, and all <code>[implemented_by ...]</code> and <code>[extern ...]</code> annotations.</p></div></div><div class="decl" id="Lean.reduceBool"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2344-L2366">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>When the kernel tries to reduce a term <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>, it will invoke the Lean interpreter to evaluate <code>c</code>.
The kernel will not use the interpreter if <code>c</code> is not a constant.
This feature is useful for performing proofs by reflection.</p><p>Remark: the Lean frontend allows terms of the from <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> t</code> where <code>t</code> is a term not containing
free variables. The frontend automatically declares a fresh auxiliary constant <code>c</code> and replaces the term with
<code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>. The main motivation is that the code for <code>t</code> will be pre-compiled.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p><p>Recall that the compiler trusts the correctness of all <code>[implemented_by ...]</code> and <code>[extern ...]</code> annotations.
If an extern function is executed, then the trusted code base will also include the implementation of the associated
foreign function.</p></div></div><div class="decl" id="Lean.reduceNat"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2368-L2378">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Similar to <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> for closed <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> terms.</p><p>Remark: we do not have plans for supporting a generic <code>reduceValue {α} (a : α) : α := a</code>.
The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.
We believe <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> enables most interesting applications (e.g., proof by reflection).</p></div></div><div class="decl" id="Lean.ofReduceBool"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2381-L2394">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceBool">ofReduceBool</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>This axiom is usually not used directly, because it has some syntactic restrictions.
Instead, the <code>native_decide</code> tactic can be used to prove any proposition whose
decidability instance can be evaluated to <code>true</code> using the lean compiler / interpreter.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="Lean.ofReduceNat"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2396-L2405">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Core.html#Lean.reduceNat">reduceNat</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceNat">ofReduceNat</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="Lean.opaqueId"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2408-L2411">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.opaqueId"><span class="name">Lean</span>.<span class="name">opaqueId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>The term <code><a href=".././Init/Core.html#Lean.opaqueId">opaqueId</a> x</code> will not be reduced by the kernel.</p></div></div><div class="decl" id="ge_iff_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2415-L2415">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ge_iff_le"><span class="name">ge_iff_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">y</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="gt_iff_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2417-L2417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#gt_iff_lt"><span class="name">gt_iff_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href=".././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">y</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="le_of_eq_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2419-L2419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#le_of_eq_of_le"><span class="name">le_of_eq_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="le_of_le_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2421-L2421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#le_of_le_of_eq"><span class="name">le_of_le_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="lt_of_eq_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2423-L2423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#lt_of_eq_of_lt"><span class="name">lt_of_eq_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="lt_of_lt_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2425-L2425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#lt_of_lt_of_eq"><span class="name">lt_of_lt_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Std.Associative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2430-L2436">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Associative"><span class="name">Std</span>.<span class="name">Associative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Associative">Associative</a> op</code> indicates <code>op</code> is an associative operation,
i.e. <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p><ul class="structure_fields" id="Std.Associative.mk"><li id="Std.Associative.assoc" class="structure_field"><div class="structure_field_info">assoc<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">(<span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">(<span class="fn">op</span> <span class="fn">b</span> <span class="fn">c</span>)</span></span></div><div class="structure_field_doc"><p>An associative operation satisfies <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Associative" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Commutative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2438-L2444">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Commutative"><span class="name">Std</span>.<span class="name">Commutative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Commutative">Commutative</a> op</code> says that <code>op</code> is a commutative operation,
i.e. <code>a ∘ b = b ∘ a</code>.</p><ul class="structure_fields" id="Std.Commutative.mk"><li id="Std.Commutative.comm" class="structure_field"><div class="structure_field_info">comm<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">b</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>A commutative operation satisfies <code>a ∘ b = b ∘ a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Commutative" class="instances-list"></ul></details></div></div><div class="decl" id="Std.IdempotentOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2446-L2452">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.IdempotentOp"><span class="name">Std</span>.<span class="name">IdempotentOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.IdempotentOp">IdempotentOp</a> op</code> indicates <code>op</code> is an idempotent binary operation.
i.e. <code>a ∘ a = a</code>.</p><ul class="structure_fields" id="Std.IdempotentOp.mk"><li id="Std.IdempotentOp.idempotent" class="structure_field"><div class="structure_field_info">idempotent<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div><div class="structure_field_doc"><p>An idempotent operation satisfies <code>a ∘ a = a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.IdempotentOp" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LeftIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2454-L2460">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LeftIdentify op o</code> indicates <code>o</code> is a left identity of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and
is used primarily for inferring the identity using class resolution.</p><ul class="structure_fields" id="Std.LeftIdentity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LeftIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulLeftIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2462-L2468">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulLeftIdentity"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#Std.LeftIdentity">Std.LeftIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LawfulLeftIdentify op o</code> indicates <code>o</code> is a verified left identity of
<code>op</code>.</p><ul class="structure_fields" id="Std.LawfulLeftIdentity.mk"><li id="Std.LawfulLeftIdentity.left_id" class="structure_field"><div class="structure_field_info">left_id<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">β</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div><div class="structure_field_doc"><p>Left identity <code>o</code> is an identity.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulLeftIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.RightIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2470-L2476">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>RightIdentify op o</code> indicates <code>o</code> is a right identity <code>o</code> of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and is used
primarily for inferring the identity using class resolution.</p><ul class="structure_fields" id="Std.RightIdentity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.RightIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulRightIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2478-L2484">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulRightIdentity"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#Std.RightIdentity">Std.RightIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LawfulRightIdentify op o</code> indicates <code>o</code> is a verified right identity of
<code>op</code>.</p><ul class="structure_fields" id="Std.LawfulRightIdentity.mk"><li id="Std.LawfulRightIdentity.right_id" class="structure_field"><div class="structure_field_info">right_id<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div><div class="structure_field_doc"><p>Right identity <code>o</code> is an identity.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulRightIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Identity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2486-L2492">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Identity"><span class="name">Std</span>.<span class="name">Identity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#Std.LeftIdentity">Std.LeftIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span>, <span class="fn"><a href=".././Init/Core.html#Std.RightIdentity">Std.RightIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Identity">Identity</a> op o</code> indicates <code>o</code> is a left and right identity of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and is used
primarily for inferring the identity using class resolution.</p><ul class="structure_fields" id="Std.Identity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Identity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2494-L2498">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulIdentity"><span class="name">Std</span>.<span class="name">LawfulIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#Std.Identity">Std.Identity</a> <span class="fn">op</span> <span class="fn">o</span></span>, <span class="fn"><a href=".././Init/Core.html#Std.LawfulLeftIdentity">Std.LawfulLeftIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span>, <span class="fn"><a href=".././Init/Core.html#Std.LawfulRightIdentity">Std.LawfulRightIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a> op o</code> indicates <code>o</code> is a verified left and right
identity of <code>op</code>.</p><ul class="structure_fields" id="Std.LawfulIdentity.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Core.html#Std.LawfulLeftIdentity.left_id">left_id</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Core.html#Std.LawfulRightIdentity.right_id">right_id</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulCommIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2500-L2511">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulCommIdentity"><span class="name">Std</span>.<span class="name">LawfulCommIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hc</span> : <span class="fn"><a href=".././Init/Core.html#Std.Commutative">Commutative</a> <span class="fn">op</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Core.html#Std.LawfulIdentity">Std.LawfulIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.LawfulCommIdentity">LawfulCommIdentity</a></code> can simplify defining instances of <code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code>
on commutative functions by requiring only a left or right identity
proof.</p><p>This class is intended for simplifying defining instances of
<code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code> and functions needed commutative operations with
identity should just add a <code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code> constraint.</p><ul class="structure_fields" id="Std.LawfulCommIdentity.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Core.html#Std.LawfulLeftIdentity.left_id">left_id</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Core.html#Std.LawfulRightIdentity.right_id">right_id</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulCommIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.instCommutativeOr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2513-L2513">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeOr"><span class="name">Std</span>.<span class="name">instCommutativeOr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Commutative</a> <a href=".././Init/Prelude.html#Or">Or</a></span></div></div></div></div><div class="decl" id="Std.instCommutativeAnd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2514-L2514">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeAnd"><span class="name">Std</span>.<span class="name">instCommutativeAnd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Commutative</a> <a href=".././Init/Prelude.html#And">And</a></span></div></div></div></div><div class="decl" id="Std.instCommutativeIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2515-L2515">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeIff"><span class="name">Std</span>.<span class="name">instCommutativeIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Commutative</a> <a href=".././Init/Core.html#Iff">Iff</a></span></div></div></div></div><div class="decl" id="Std.Refl"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2517-L2520">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Refl"><span class="name">Std</span>.<span class="name">Refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Refl">Refl</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> means the binary relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is reflexive, that is, <code><a href=".././Init/Core.html#Setoid.r">r</a> x x</code> always holds.</p><ul class="structure_fields" id="Std.Refl.mk"><li id="Std.Refl.refl" class="structure_field"><div class="structure_field_info">refl<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>A reflexive relation satisfies <code><a href=".././Init/Core.html#Setoid.r">r</a> a a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Refl" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Antisymm"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2522-L2525">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Antisymm"><span class="name">Std</span>.<span class="name">Antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Antisymm">Antisymm</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> says that <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is antisymmetric, that is, <code><a href=".././Init/Core.html#Setoid.r">r</a> a b → <a href=".././Init/Core.html#Setoid.r">r</a> b a → a = b</code>.</p><ul class="structure_fields" id="Std.Antisymm.mk"><li id="Std.Antisymm.antisymm" class="structure_field"><div class="structure_field_info">antisymm<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div><div class="structure_field_doc"><p>An antisymmetric relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> satisfies <code><a href=".././Init/Core.html#Setoid.r">r</a> a b → <a href=".././Init/Core.html#Setoid.r">r</a> b a → a = b</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Antisymm" class="instances-list"></ul></details></div></div><div class="decl" id="Antisymm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2527-L2528">source</a></div><div class="attributes">@[reducible, inline, deprecated Std.Antisymm (since := &quot;2024-10-16&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Antisymm"><span class="name">Antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Antisymm">Antisymm</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> says that <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is antisymmetric, that is, <code><a href=".././Init/Core.html#Setoid.r">r</a> a b → <a href=".././Init/Core.html#Setoid.r">r</a> b a → a = b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Antisymm">Antisymm</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Antisymm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Asymm"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2530-L2534">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Asymm"><span class="name">Std</span>.<span class="name">Asymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Asymm">Asymm</a> X <a href=".././Init/Core.html#Setoid.r">r</a></code> means that the binary relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> on <code>X</code> is asymmetric, that is,
<code><a href=".././Init/Core.html#Setoid.r">r</a> a b → ¬ <a href=".././Init/Core.html#Setoid.r">r</a> b a</code>.</p><ul class="structure_fields" id="Std.Asymm.mk"><li id="Std.Asymm.asymm" class="structure_field"><div class="structure_field_info">asymm<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>An asymmetric relation satisfies <code><a href=".././Init/Core.html#Setoid.r">r</a> a b → ¬ <a href=".././Init/Core.html#Setoid.r">r</a> b a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Asymm" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Total"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2536-L2540">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Total"><span class="name">Std</span>.<span class="name">Total</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Total">Total</a> X <a href=".././Init/Core.html#Setoid.r">r</a></code> means that the binary relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> on <code>X</code> is total, that is, that for any
<code>x y : X</code> we have <code><a href=".././Init/Core.html#Setoid.r">r</a> x y</code> or <code><a href=".././Init/Core.html#Setoid.r">r</a> y x</code>.</p><ul class="structure_fields" id="Std.Total.mk"><li id="Std.Total.total" class="structure_field"><div class="structure_field_info">total<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>A total relation satisfies <code><a href=".././Init/Core.html#Setoid.r">r</a> a b ∨ <a href=".././Init/Core.html#Setoid.r">r</a> b a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Total" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Irrefl"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/81b85203c90439fb7d7e0cec32130d62d8cb7a2e/src/Init/Core.lean#L2542-L2546">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Irrefl"><span class="name">Std</span>.<span class="name">Irrefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Irrefl">Irrefl</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> means the binary relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is irreflexive, that is, <code><a href=".././Init/Core.html#Setoid.r">r</a> x x</code> never
holds.</p><ul class="structure_fields" id="Std.Irrefl.mk"><li id="Std.Irrefl.irrefl" class="structure_field"><div class="structure_field_info">irrefl<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>An irreflexive relation satisfies <code>¬ <a href=".././Init/Core.html#Setoid.r">r</a> a a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Irrefl" class="instances-list"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>